[{"title":"0-1分布参数的区间估计","url":"/2022/01/06/0-1%E5%88%86%E5%B8%83%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BC%B0%E8%AE%A1/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/0-1%E5%88%86%E5%B8%83%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BC%B0%E8%AE%A1.pdf\") \n","categories":["概率论与数理统计"]},{"title":"二叉搜索树的验证、查找、插入和删除","url":"/2022/06/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/","content":"二叉搜索树的查找、插入和删除二叉搜索树二叉搜索树又被称为二叉排序树，它本身也是一棵二叉树，且满足以下性质：\n\n若左子树不为空，则左子树上左右节点的值都小于根节点的值\n若它的右子树不为空，则它的右子树上所有的节点的值都大于根节点的值\n它的左右子树也要分别是二叉搜索树\n\nstruct TreeNode &#123;\t\tint val;\t\tTreeNode *left;\t\tTreeNode *right;\t\tTreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) \t\t&#123;&#125;&#125;;\n\n验证是否为二叉搜索树递归法利用有效二叉树的定义：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\nbool helper(TreeNode* root, long long lower, long long upper)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn true;\t\t&#125;\t\tif (root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)&#123;\t\t\t\treturn false;\t\t&#125;\t\treturn helper(root-&gt;left, lower, root-&gt;val)       \t\t\t&amp;&amp; helper(root-&gt;right, root-&gt;val, upper);&#125;bool isValidBST(TreeNode* root) &#123;\t\treturn helper(root, LONG_MIN, LONG_MAX);&#125;\n\n中序遍历中序遍历结果应为递增序列\n二叉搜索树的查找TreeNode* searchBST(TreeNode* root, int val) &#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn nullptr;\t\t&#125;\t\tif (root-&gt;val == val)&#123;\t\t\t\treturn root;\t\t&#125;\t\treturn root-&gt;val &gt; val ? searchBST(root-&gt;left, val) : searchBST(root-&gt;right, val);&#125;\n\n二叉搜素树的插入当将 val插入到以 root为根的子树上时，根据 val与 root.val的大小关系，就可以确定要将 val插入到哪个子树中：\n\n如果该子树不为空，则问题转化成了将 val插入到对应子树上\n否则，在此处新建一个以 val为值的节点，并链接到其父节点 root上\n\nTreeNode* insertIntoBST(TreeNode* root, int val) &#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn new TreeNode(val);\t\t&#125;\t\tTreeNode* pos = root;\t\twhile (pos != nullptr)&#123;\t\t\t\tif (pos-&gt;val &lt; val)&#123;\t\t\t\t\t\tif (pos-&gt;right == nullptr)&#123;\t\t\t\t\t\t\t\tpos-&gt;right = new TreeNode(val);\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t&#125; else&#123;\t\t\t\t\t\t\t\tpos = pos-&gt;right;\t\t\t\t\t\t&#125;\t\t\t\t&#125; else&#123;\t\t\t\t\t\tif (pos-&gt;left == nullptr)&#123;\t\t\t\t\t\t\t\tpos-&gt;left = new TreeNode(val);\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t&#125; else&#123;\t\t\t\t\t\t\t\tpos = pos-&gt;left;\t\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t&#125;\t\treturn root;&#125;\n\n二叉搜索树的的删除删除操作比较复杂，可以分为以下三种情况：\n\n被删除节点为叶子节点：直接删除该节点\n被删除结点有一个左孩子或一个右孩子：将孩子结点设为该结点的父结点的孩子后，即可删除该结点\n被删除结点有两个孩子结点：一般的删除策略是，用被删除结点的右子树中的最小结点替代被删除结点，并递归地删除这个最小数据结点\n\n利用前继和后继节点也可以分为以下三种情况：\n\n要删除的节点为叶子节点，可以直接删除\n\n\n\n要删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点\n\n\n\n删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点\n\n\n//寻找后继节点TreeNode* successor(TreeNode* root)&#123;\t\troot = root-&gt;right;\t\twhile (root-&gt;left != nullptr)&#123;\t\t\t\troot = root-&gt;left;\t\t&#125;\t\treturn root;&#125;//寻找前继节点TreeNode* predecessor(TreeNode* root)&#123;\t\troot = root-&gt;left;\t\twhile (root-&gt;right != nullptr)&#123;\t\t\t\troot = root-&gt;right;\t\t&#125;\t\treturn root;&#125;TreeNode* deleteNode(TreeNode* root, int key) &#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn nullptr;\t\t&#125;\t\tif (root-&gt;val &gt; key)&#123; //在左子树中寻找要删除的节点\t\t\t\troot-&gt;left = deleteNode(root-&gt;left, key);\t\t&#125; else if(root-&gt;val &lt; key)&#123; //在右子树中寻找要删除的节点\t\t\t\troot-&gt;right = deleteNode(root-&gt;right, key);\t\t&#125; else&#123; //找到要删除的节点\t\t\t\tif (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;          \t//如果是叶子节点，则直接删除\t\t\t\t\t\troot = nullptr;\t\t\t\t&#125; else if (root-&gt;right != nullptr)&#123;           \t//如果有右子树，则用其后继值代替，并递归的删除这个后继节点\t\t\t\t\t\troot-&gt;val = successor(root)-&gt;val;\t\t\t\t\t\troot-&gt;right = deleteNode(root-&gt;right, root-&gt;val);\t\t\t\t&#125; else&#123;          \t//如果左右子树，则用其后继值代替，并递归的删除这个后继节点\t\t\t\t\t\troot-&gt;val = predecessor(root)-&gt;val;\t\t\t\t\t\troot-&gt;left = deleteNode(root-&gt;left, root-&gt;val);\t\t\t\t&#125;\t\t&#125;\t\treturn root;&#125;//注意：这里的前继节点和后继节点并不是严格意义上的，而是建立在左（右）子树存在的基础上的\n\n","categories":["数据结构与算法"]},{"title":"PCA","url":"/2022/01/06/PCA/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/PCA.pdf\") \n","categories":["概率论与数理统计"]},{"title":"TypeScript安装","url":"/2022/07/11/TypeScript%E5%AE%89%E8%A3%85/","content":"TypeScript安装建议采用局部安装，即只安装到项目目录下，不建议全局安装，尤其是在用nvm管理nodejs版本的情况下更不建议了。\nMacOS和Linux所有操作都是在项目目录下进行的\nsudo npm install typescript -D\n\nsudo npm install ts-node -D\n\n如果要直接运行.ts文件的话，输入\nnpx ts-node 文件名.ts \n\n如果要编译为js文件的话，输入\nnpx tsc 文件名.ts  \n\nWindows所有操作都是在项目目录下进行的\n以管理员模式运行cmd，定位到项目目录\nnpm install typescript -D\n\nnpm install ts-node -D\n\n如果要直接运行.ts文件的话，输入\nnpx ts-node 文件名.ts \n\n如果要编译为js文件的话，输入\nnpx tsc 文件名.ts \n\n","categories":["编程环境安装和配置"]},{"title":"二叉树的遍历","url":"/2022/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","content":"二叉树的遍历二叉树节点的定义struct TreeNode &#123;\t\tint val;\t\tTreeNode *left;\t\tTreeNode *right;\t\tTreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) \t\t&#123;&#125;&#125;;\n\n前序遍历递归实现vector&lt;int&gt; preOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tpreOrder(root,res);\t\treturn res;&#125;    void preOrder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn;\t\t&#125;\t\tres.push_back(root-&gt;val);\t\tpreOrder(root-&gt;left,res);\t\tpreOrder(root-&gt;right,res);&#125;\n\n非递归实现当栈不为空时，栈顶元素出栈，如果其右子节点不为空，则右子节点入栈，其左字节点不为空，则左字节点入栈，这样出栈时，则会先出左子节点，再出右子节点，则能够完成树的前序遍历\nvector&lt;int&gt; preOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tif (root == nullptr)&#123;\t\t\t\treturn res;\t\t&#125;\t\tstack&lt;TreeNode*&gt; s;\t\ts.push(root);\t\twhile (!s.empty())&#123;\t\t\t\tTreeNode* temp = s.top();\t\t\t\ts.pop();\t\t\t\tres.push_back(temp-&gt;val);\t\t\t\tif (temp-&gt;right)&#123;\t\t\t\t\t\ts.push(temp-&gt;right);\t\t\t\t&#125;\t\t\t\tif (temp-&gt;left)&#123;\t\t\t\t\t\ts.push(temp-&gt;left);\t\t\t\t&#125;\t\t&#125;\t\treturn res;&#125;\n\n中序遍历递归实现vector&lt;int&gt; inOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tinOrder(root,res);\t\treturn res;&#125;void inOrder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn;\t\t&#125;\t\tinOrder(root-&gt;left,res);\t\tres.push_back(root-&gt;val);\t\tinOrder(root-&gt;right,res);&#125;\n\n非递归实现vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tif (root == nullptr)&#123;\t\t\t\treturn res;\t\t&#125;\t\tstack&lt;TreeNode*&gt; stk;\t\twhile (!stk.empty() || root != nullptr)&#123;\t\t\t\t//不断往左子树方向走，每走一次就将当前节点保存到栈中\t\t\t\twhile (root != nullptr)&#123;\t\t\t\t\t\tstk.push(root);\t\t\t\t\t\troot = root-&gt;left;\t\t\t\t&#125;\t\t\t\t//当前节点为空，说明左边走到头了，从栈中弹出节点并保存\t\t\t\t//然后转向右边节点，继续上面整个过程\t\t\t\troot = stk.top();\t\t\t\tstk.pop();\t\t\t\tres.push_back(root-&gt;val);\t\t\t\troot = root-&gt;right;\t\t&#125;\t\treturn res;&#125;\n\n后序遍历递归实现vector&lt;int&gt; postOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tpostOrder(root,res);\t\treturn res;&#125;void postOrder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn;\t\t&#125;\t\tpostOrder(root-&gt;left,res);\t\tpostOrder(root-&gt;right,res);\t\tres.push_back(root-&gt;val);&#125;\n\n非递归实现因为后序遍历二叉树的顺序是先访问左子树，再访问右子树，最后访问根节点。当用堆栈来存储节点，必须分清返回根节点时，是从左子树返回的，还从右子树返回的。所以，使用辅助指针prev指向最近访问过的节点，来判断是否从右子树返回。也可以在节点中增加一个标志域，记录是否已被访问。\nvector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tif (root == nullptr)&#123;\t\t\t\treturn res;\t\t&#125;\t\tstack&lt;TreeNode*&gt; stk;\t\tTreeNode* prev = nullptr;\t\twhile (root != nullptr || !stk.empty())&#123;\t\t\t\twhile (root != nullptr)&#123;//不断往左子树方向走\t\t\t\t\t\tstk.push(root);\t\t\t\t\t\troot = root-&gt;left;\t\t\t\t&#125;\t\t\t\troot = stk.top();\t\t\t\tstk.pop();\t\t\t\tif (root-&gt;right &amp;&amp; root-&gt;right != prev)&#123;//右子树存在且未被访问\t\t\t\t\t\tstk.push(root);//从左子树返回，不能弹出根节点，应再压回栈内\t\t\t\t\t\troot = root-&gt;right;\t\t\t\t&#125;else&#123;\t\t\t\t\t\tres.push_back(root-&gt;val);\t\t\t\t\t\tprev = root;\t\t\t\t\t\troot = nullptr;\t\t\t\t&#125;\t\t&#125;\t\treturn res;&#125;\n\n按层次遍历//遍历结果将一个层次存储到一个vector中vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;\t\tvector&lt;vector&lt;int&gt;&gt; result;\t\t//树为空直接返回\t\tif (root == nullptr)&#123;\t\t\t\treturn result;\t\t&#125;\t\tqueue&lt;TreeNode*&gt; q;\t\tq.push(root); //先将根节点入队\t\twhile (!q.empty())&#123;\t\t\t\tvector&lt;int&gt; temp;\t\t\t\tint n = q.size();\t\t\t\tfor (int i = 0; i &lt; n; i++)&#123;\t\t\t\t\t\tTreeNode* node = q.front();\t\t\t\t\t\tq.pop(); //出队并保存节点\t\t\t\t\t\ttemp.push_back(node-&gt;val);\t\t\t\t\t\t//将节点的左子树入队\t\t\t\t\t\tif (node-&gt;left != nullptr)&#123;\t\t\t\t\t\t\t\tq.push(node-&gt;left);\t\t\t\t\t\t&#125;            //将节点的右子树入队\t\t\t\t\t\tif (node-&gt;right != nullptr)&#123;\t\t\t\t\t\t\t\tq.push(node-&gt;right);\t\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tresult.push_back(temp);\t\t&#125;\t\treturn result;&#125;\n\n","categories":["数据结构与算法"]},{"title":"人机交互与用户设计体验MOOC习题","url":"/2023/08/07/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E4%B8%8E%E7%94%A8%E6%88%B7%E8%AE%BE%E8%AE%A1%E4%BD%93%E9%AA%8CMOOC%E4%B9%A0%E9%A2%98/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/HCI/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E4%B8%8E%E7%94%A8%E6%88%B7%E8%AE%BE%E8%AE%A1%E4%BD%93%E9%AA%8CMOOC%E4%B9%A0%E9%A2%98.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1722502596&Signature=tRzrB6I%2B14VgEDbIAjwTOGwjJhI%3D\") \n","categories":["人机交互系统"]},{"title":"人机交互与用户设计体验MOOC习题答案","url":"/2023/07/20/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E4%B8%8E%E7%94%A8%E6%88%B7%E8%AE%BE%E8%AE%A1%E4%BD%93%E9%AA%8CMOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/hci/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E4%B8%8E%E7%94%A8%E6%88%B7%E8%AE%BE%E8%AE%A1%E4%BD%93%E9%AA%8CMOOC%E4%B9%A0%E9%A2%98.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1720925853&Signature=%2BkwKf4QZ1RxMhWZEMCG2jSWHOM4%3D\") ","categories":["人机交互系统"]},{"title":"商业模式","url":"/2022/12/01/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/requirement/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258361&Signature=PrikJXxF/xrSIng5cRbJ1zZHCCc%3D\") \n\n","categories":["需求与商业模式创新"]},{"title":"信号量与PV操作","url":"/2022/12/20/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8EPV%E6%93%8D%E4%BD%9C/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8EPV%E6%93%8D%E4%BD%9C.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995200&Signature=lhopjzeThmiNxY57mRkLA87Jfpk%3D\") ","categories":["操作系统"]},{"title":"商务智能简答题整理","url":"/2022/12/18/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E7%AE%80%E7%AD%94%E9%A2%98%E6%95%B4%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/business%20intelligence/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E7%AE%80%E7%AD%94%E9%A2%98.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707790284&Signature=8fZMcjNQsn78ua1Z5gHopSIosfA%3D\") ","categories":["商务智能"]},{"title":"商务智能选择题整理","url":"/2022/12/18/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/business%20intelligence/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E9%80%89%E6%8B%A9%E9%A2%98.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707790300&Signature=VILOTsdcoeXvwUB8Jmgle64JCy4%3D\") ","categories":["商务智能"]},{"title":"处理器调度算法","url":"/2022/12/20/%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995187&Signature=bkqMeVukXizWo5XIJ/DQ65p4Qbc%3D\") ","categories":["操作系统"]},{"title":"常见函数的级数展开","url":"/2022/01/06/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80.pdf\") \n","categories":["概率论与数理统计"]},{"title":"常见概率分布的期望和方差","url":"/2022/01/06/%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%92%8C%E6%96%B9%E5%B7%AE/","content":" location.replace(\"https://vohsiliu.gitee.io/pdfblog/%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%92%8C%E6%96%B9%E5%B7%AE.pdf\") \n\n","categories":["概率论与数理统计"]},{"title":"操作系统MOOC习题答案","url":"/2022/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FMOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FMOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702870212&Signature=NjmQ%2BfSvwUkMxW5XJH8Eid2wj8o%3D\") \n\n","categories":["操作系统"]},{"title":"操作系统课后作业1","url":"/2022/12/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A1/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E4%BD%9C%E4%B8%9A1.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702992997&Signature=ib3SUNwNV75qfHwu57ukNptbi3I%3D\") \n","categories":["操作系统"]},{"title":"操作系统课后作业2","url":"/2022/12/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A2/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E4%BD%9C%E4%B8%9A2.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702993066&Signature=9qRnXcxYfBZ4sBsUtl31qUIx0kg%3D\") \n","categories":["操作系统"]},{"title":"操作系统选择题整理","url":"/2022/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719825733&Signature=6UZlZ5FF9ToTMwU0Jfr6CHW4hmc%3D\") ","categories":["操作系统"]},{"title":"数据热力学","url":"/2022/01/06/%E6%95%B0%E6%8D%AE%E7%83%AD%E5%8A%9B%E5%AD%A6/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/%E6%95%B0%E6%8D%AE%E7%83%AD%E5%8A%9B%E5%AD%A6.pdf\") \n","categories":["概率论与数理统计"]},{"title":"服务计算与服务生态系统MOOC习题答案","url":"/2023/04/02/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9FMOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/SOA/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9FMOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1711529799&Signature=bvA3SZTQNH6eM3N%2Bj4iJpU1bSrE%3D\") ","categories":["面向服务的软件工程"]},{"title":"期末考试重点","url":"/2022/12/28/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/requirement/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1706155223&Signature=aHiJaQDXUW9Rf6KiRFZ5YccjFT4%3D\") ","categories":["需求与商业模式创新"]},{"title":"概率论与数理统计笔记","url":"/2022/01/06/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/Probability.pdf\") \n\n","categories":["概率论与数理统计"]},{"title":"正态总体均值、方差的检验法","url":"/2022/01/06/%E6%AD%A3%E6%80%81%E6%80%BB%E4%BD%93%E5%9D%87%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%9A%84%E6%A3%80%E9%AA%8C%E6%B3%95/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/%E6%AD%A3%E6%80%81%E6%80%BB%E4%BD%93%E5%9D%87%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%9A%84%E6%A3%80%E9%AA%8C%E6%B3%95.pdf\") \n","categories":["概率论与数理统计"]},{"title":"正态总体均值、方差的置信区间与单侧置信限","url":"/2022/01/06/%E6%AD%A3%E6%80%81%E6%80%BB%E4%BD%93%E5%9D%87%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%9A%84%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E4%B8%8E%E5%8D%95%E4%BE%A7%E7%BD%AE%E4%BF%A1%E9%99%90/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/%E6%AD%A3%E6%80%81%E6%80%BB%E4%BD%93%E5%9D%87%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%9A%84%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E4%B8%8E%E5%8D%95%E4%BE%A7%E7%BD%AE%E4%BF%A1%E9%99%90.pdf\") \n","categories":["概率论与数理统计"]},{"title":"磁盘调度算法","url":"/2022/12/20/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995168&Signature=O2MADOuGaTtyErayj27H2kOuiH0%3D\") ","categories":["操作系统"]},{"title":"第一章 操作系统概论","url":"/2022/07/26/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter1.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258176&Signature=iQq2I0tcLemlhxU3WsuVoycJ2AM%3D\") \n\n","categories":["操作系统"]},{"title":"第一章 概述","url":"/2022/06/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter1.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826785&Signature=1OxBN5xrUUAPI9RZiZkfDzxv8wI%3D\") ","categories":["计算机网络"]},{"title":"第一章 绪论","url":"/2022/06/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/database/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719827064&Signature=P0dprpLQHhspdtFWG73mFvIu/9E%3D\") ","categories":["数据库"]},{"title":"第一章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第七章 数据库设计","url":"/2022/06/06/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/database/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719827239&Signature=ZFriGc33xeedHQrepE/ThTGXVhk%3D\") ","categories":["数据库"]},{"title":"第七章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第三章 关系数据库标准语言SQL","url":"/2022/06/06/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/database/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719827121&Signature=ju20C5jNueAGn3Lm%2B789K6CYVck%3D\") ","categories":["数据库"]},{"title":"第三章 存储管理","url":"/2022/08/13/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter3.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258245&Signature=D7s0GAQ1YjosQ7iAn6lmCnghs9o%3D\") \n\n","categories":["操作系统"]},{"title":"第三章 数据链路层","url":"/2022/06/06/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter3.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826857&Signature=4p77pi9HqI5FynjGdJzQTi7uKe0%3D\") ","categories":["计算机网络"]},{"title":"第九章 无线网络和移动网络","url":"/2022/06/06/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/","content":"第九章 无线网络和移动网络9.1 无线局域网WLAN9.1.1 无线局域网的组成无线局域网可分为有固定基础设施的和无固定基础设施的两大类。“固定基础设施”是指预先建立起来的、能够覆盖一定地理范围的一批固定基站\n1. IEEE 802.11\n对于第一类有固定基础设施的无线局域网，1997 年 IEEE 制定出无线局域网的协议标准 802.11[W-IEEE802.11]系列标准\n802.11 是无线以太网的标准，它使用星形拓扑，其中心叫做接入点 AP（Access Point），在 MAC 层使用 CSMA/CA 协议\n凡使用 802.11 系列协议的局域网又称为 Wi-Fi（Wireless-Fidelity，意思是“无线保真度”）\n现在 Wi-Fi 实际上已经成为了无线局域网 WLAN 的代名词，但无线局域网和“保真度”实在没有什么关系\n802.11 标准规定无线局域网的最小构件是基本服务集 BSS（Basic Service Set）\n一个基本服务集 BSS 包括一个基站和若干个移动站，一个站无论要和本 BSS 的站进行通信，还是要和其他 BSS 的站进行通信，都必须通过本 BSS 的基站\n\n\n\n9.1.2 802.11 局域网的物理层9.1.3 802.11 局域网的MAC层1. CSMA/CA 协议\n在无线局域网中，仍然可以使用载波监听多址接入 CSMA , 即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞\n在无线局域网中，不能使用碰撞检测CD ，原因如下：\n由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD ，对硬件的要求非常高\n即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题）， 进行碰撞检测的意义也不大\n\n\n\n\n\n802.11 无线局域网使用 CSMA/CA 协议，在 CSMA 的基础上增加了一个碰撞避免 CA 功能，而不再实现碰撞检测功能\n\n由于不可能避免所有的碰撞，并且无线信道误码率较高， 802.11 标准还使用了数据链路层确认机制（停止-等待协议） 来保证数据被正确接收\n\n802.11 的 MAC 层标准定义了两种不同的媒体接入控制方式：\n\n分布式协调功能 DCF（Distributed Coordination Function）。在 DCF 方式下，没有中心控制站点，每个站点使用 CSMA/CA 协议通过争用信道来获取发送权，这是802.11 定义的默认方式\n\n点协调功能 PCF（Point Coordination Function）。PCF 方式使用集中控制的接入算法（一般在接入点AP 实现集中控制），是802.11 定义的可选方式，在实际中较少使用\n\n\n\n802.11 标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔IFS（InterFrame Space）\n\n帧间间隔的长短取决于该站点要发送的帧的类型：\n\n高优先级帧需要等待的时间较短，因此可优先获得发送权；\n优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。\n\n\n常用的两种帧间间隔如下：\n\n短帧间间隔 SIFS（），是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用 SIFS 的帧类型有 ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧、以及所有回答 AP 探询的帧和在 PCF 方式中接入点 AP 发送出的任何帧\nDCF 帧间间隔 DIFS（），它比短帧间间隔 SIFS 要长得多，在 DCF 方式中用来发送数据帧和管理帧\n\n\n\nCSMA/CA 协议工作原理：\n\n\n当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法\n以下情况必须使用退避算法：\n在发送数据帧之前检测到信道处于忙状态时\n每一次重传一个数据帧时\n在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）\n\n\n在执行退避算法时，站点为退避计时器设置一个随机的退避时间：\n当退避计时器的时间减小到零时，就开始发送数据\n当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间 DIFS 后，继续启动退避计时器\n\n\n在进行第次退避时，退避时间在时隙编号中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少.当时隙编号达到255时（对应于第6次退避）就不再增加了\n\n\n2. 对信道进行预约\n为了尽可能减少碰撞的概率和降低碰撞的影响， 802.11 标准允许要发送数据的站点对信道进行预约\n源站在发送数据帧之前先发送一个短的控制帧，称为请求发送 RTS（request to send），它包括源地址目的地址以及这次通信（包括相应的确认帧）所需的持续时间\n\n若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送 CTS（clear to send），它也包括这次通信所需的持续时间（从 RTS 帧中将此持续时间复制到 CTS 帧中）\n\n源站收到 CTS 帧后，再等待一段时间 SIFS 后，就可发送其数据帧\n\n若目的站正确收到了源站发来的数据帧，在等待时间 SIFS 后，就向源站发送确认帧 ACK\n\n\n\n\n\n\n\n除源站和目的站以外的其他各站，在收到 CTS 帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰\n\n如果 RTS 帧发生碰撞，源站就收不到 CTS 帧，需执行退避算法重传 RTS 帧\n\n由于RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。802.11 标准规定了3种情况供用户选择：\n\n使用 RTS 帧和 CTS 帧\n不使用 RTS 帧和 CTS 帧\n只有当数据帧的长度超过某一数值时才使用 RTS 帧和 CTS 帧\n\n\n除 RTS 帧和 CTS 帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的虚拟载波监听机制\n\n由于利用虚拟载波监听机制， 站点只要监听到 RTS 帧、CTS 帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题\n\n\nCSMA/CA的基本流程图：\n\n\n\n\n9.1.4 802.11 局域网的MAC帧","categories":["计算机网络"]},{"title":"第九章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第二章 关系数据库","url":"/2022/06/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/database/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719827097&Signature=yWrtvUD1NLEc50ROh6VIPSX%2BPVs%3D\") ","categories":["数据库"]},{"title":"第二章 处理器管理","url":"/2022/08/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter2.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258226&Signature=/zGkKDmAUdHaZZDvivrmsPw3n90%3D\") \n\n","categories":["操作系统"]},{"title":"第二章 物理层","url":"/2022/06/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter2.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826799&Signature=RnEvLUDCMC7sltFgAzbW5C4Yjd8%3D\") \n","categories":["计算机网络"]},{"title":"第五章 数据库完整性","url":"/2022/06/06/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/database/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719827203&Signature=symgR31HQR8jaRkmHn7CuaWDhdo%3D\") ","categories":["数据库"]},{"title":"第五章 文件管理","url":"/2022/08/25/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter5.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258277&Signature=oJrKQK4/Rsutsm%2BLiSBBCom6zyY%3D\") \n","categories":["操作系统"]},{"title":"第五章 运输层","url":"/2022/06/06/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter5.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826906&Signature=LhvetstPJinYML5qonWz%2BBpH4Ks%3D\") ","categories":["计算机网络"]},{"title":"第六章 关系数据理论","url":"/2022/06/06/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/database/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719827217&Signature=bfeVqiPv3abWKgAtZpX3V0NC%2BOM%3D\") ","categories":["数据库"]},{"title":"第八章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%85%AB%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%85%AB%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第六章 并发程序设计","url":"/2022/08/25/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter6.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258300&Signature=h9nWKnDXGD6GEVODburGTb9DgQI%3D\") \n\n","categories":["操作系统"]},{"title":"第六章 应用层","url":"/2022/06/06/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter6.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826935&Signature=LG3rTcNRakoeJYgV59PfbXtqVXY%3D\") ","categories":["计算机网络"]},{"title":"第六章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第十三章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第十一章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第十五章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第十四章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第十六章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第十章 数据库恢复技术","url":"/2022/06/06/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/database/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719827266&Signature=G1i5czkFlZLduvB01za%2B2Dsynfg%3D\") ","categories":["数据库"]},{"title":"第十二章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第十章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第四章 数据库安全性","url":"/2022/06/06/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/database/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719827145&Signature=V/DCToq2B54O/e34pvXUU2geqdo%3D\") ","categories":["数据库"]},{"title":"第四章 设备管理","url":"/2022/08/17/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter4.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258263&Signature=6R%2BDht5BONGn2L7vG6GXAKMN3jw%3D\") \n\n","categories":["操作系统"]},{"title":"第四章 网络层","url":"/2022/06/06/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter4.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826884&Signature=o/CCI0cjGXUOUymmn5PBmuQ%2Bo0g%3D\") ","categories":["计算机网络"]},{"title":"网站部署","url":"/2022/12/01/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/","content":" location.replace(\"https://blog.csdn.net/qq_35561857/article/details/81590953\") \n","categories":["编程环境安装和配置"]},{"title":"线性代数笔记","url":"/2022/01/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/Linear%20Algebra.pdf\") \n","categories":["线性代数"]},{"title":"设计模式","url":"/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/design%20patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1705980442&Signature=%2BaKivp4TFATQimrwUDxqCvtgNMc%3D\") \n\n","categories":["设计模式"]},{"title":"自动化测试MOOC习题答案","url":"/2022/11/07/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95MOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/automated%20testing/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95MOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1704202047&Signature=sr%2BeoUa/%2BA7pitDn%2ByYh6jAB3V0%3D\") \n","categories":["自动化测试"]},{"title":"自动化测试期末复习","url":"/2022/11/07/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/automated%20testing/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1704201996&Signature=2CaCGk9IhYQCMYoFatIHj8Tj6OE%3D\") \n","categories":["自动化测试"]},{"title":"设计模式期末复习","url":"/2023/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/design%20patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719824974&Signature=pQ0i3tqB8p5dBgPtZ7gw2Yhs0BQ%3D\") ","categories":["设计模式"]},{"title":"质数筛","url":"/2022/06/06/%E8%B4%A8%E6%95%B0%E7%AD%9B/","content":"质数筛埃氏筛素数筛法，是一种快速“筛”出​​之间所有素数的方法。\n朴素的筛法叫埃氏筛（the Sieve of Eratosthenes，埃拉托色尼筛），它的过程是这样的：\n先将​​​​的数按顺序写出来：从前往后看，找到第一个未被划掉的数，是2，说明它是质数（这里是质数用标为蓝色表示）。然后把2的倍数（不包括2）划掉（这里划掉用标红表示）：\n下一个未被划掉的数是3，它是质数，然后把3的倍数划掉：接下来应该是5，但是由于5已经超过​了，所以遍历结束，剩下未被划掉的都是素数：这个过程用代码表示为：\nbool isPrime[MAXN+5] = {0};//标记数组 用来表示数字是否是质数：true表示是质数，false表示不是质数void aiPrime(int n){//埃氏筛处理n以内的质数\tmemset(isPrime,true,sizeof(isPrime));//所有数字，默认标记为质数 \tisPrime[1] = false;//修改1的状态，1不是质数\tfor(int i = 2; i * i &lt;= n; i++){//从2开始，枚举范围n以内的每个数字 \t\tif(isPrime[i]){//如果i是质数，则将n以内所有i的倍数（2倍及以上），标记为非质数 \t\t\tfor(int j = 2; j * i &lt;= n; j++){\t\t\t\tisPrime[j*i]=false;// 标记i的倍数为非质数 \t\t\t}\t\t}\t}}\n\n埃式筛算法的复杂度是 ​​，但是我们发现，在筛的过程中我们会重复筛到同一个数，例如12同时被2和3筛到，30同时被2、3和5筛到。\n所以我们引入欧拉筛，也叫线性筛，可以在​时间内完成对的筛选。它的核心思想是：让每一个合数被其最小质因数筛到。\n欧拉筛这次除了要把​列出来，还维护一个质数表：仍然是从头到尾遍历，第一个数是2，未被划掉，把它放进质数表：然后用2去乘质数表里的每个数，并且划掉它们：下一个是3，加入质数表，并用3去乘质数表里每一个数（此时是2和3），划掉6和9：下一个是4（注意：这里划掉的数也要遍历，只是不加入质数表），用4去乘质数表里每个数，划掉8，但不划掉12，因为​​，应该由它的最小质因数2筛掉，而不是3。实际上，对于数​，当遍历到质数表中的 ​ ，且发现 ​​（能整除）时，就应当停止遍历质数表。\n\n因为如果​​​​​​，即i%p == 0​，则说明假设在质数表中​​​​的下一位是​​​​​，设所以由有，因为，设所以​​​​​，则所以如果用​​式筛掉所以如果用3式筛去​​的话，当​​时，​​又会被​​​式筛去一次，为了确保合数只被最小质因子筛掉，最小质因子要乘以最大的倍数，即要乘以最大的​​, 所以不能提前筛。\n\n下一个数是5，加入质数表，划掉10和15：下一个数是6，划掉12，6能被2整除，跳过。\n……\n按这样的步骤进行下去，可以筛掉所有的合数，并得到一张质数表：我们可以保证每个合数都被筛过。设任意合数 ，其中是的最小质因数，又设，是的最小质因数。在处理时时，要遍历质数表，直到遇到时才结束，所以任意小于等于的质数与的乘积，都会在此时被筛掉。\n而由于一定有（因为的最小质因数是，而不是），所以在处理到时，一定会被筛到。\n代码如下：\nbool isPrime[MAXN+5];  int prime[MAXM+5];  //判断是否是一个素数  Mark 标记数组 index 素数个数  void olaPrime(){    int index = 0;    memset(isPrime,true,sizeof(isPrime));      for(int i = 2; i &lt; MAXSIZE; i++){           //如果i未被标记为非素数（即false）则得到一个素数          if(isPrime[i] == true){              prime[index++] = i;          }          //标记目前得到的素数的i倍为非素数          for(int j = 0; j &lt; index &amp;&amp; prime[j] * i &lt; MAXN; j++){               isPrime[i * prime[j]] = false;              if(i % prime[j] == 0){                  break;              }          }      }    }  //如果空间不够用质数表也可以不用开始就开到最大bool isnp[MAXN];//is not primevector&lt;int&gt; primes; // 质数表void olaPrime(int n){    for (int i = 2; i &lt;= n; i++){        if (!isnp[i]){            primes.push_back(i);        }        for (int p : primes){            if (p * i &gt; n){                break;            }            isnp[p * i] = 1;            if (i % p == 0){                break;            }        }    }}\n\n欧式筛的时间复杂度为。\n","categories":["数据结构与算法"]},{"title":"软件测试MOOC习题答案","url":"/2022/11/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95MOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/automated%20testing/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95MOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1704202107&Signature=URfMYmLXxiT/Py3wvShlwIt%2BLAA%3D\") \n","categories":["自动化测试"]},{"title":"软件质量与管理期末复习","url":"/2023/08/07/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/Software%20Quality%20and%20Software%20Management/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1722502378&Signature=R3yCNQcW8WU9TOBWb1ilzXzg4pY%3D\") ","categories":["软件质量与管理"]},{"title":"霍尔管程","url":"/2022/12/20/%E9%9C%8D%E5%B0%94%E7%AE%A1%E7%A8%8B/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E9%9C%8D%E5%B0%94%E7%AE%A1%E7%A8%8B.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995258&Signature=CgmoP7XDy3%2BGRdDgiq7t41n4iFE%3D\") ","categories":["操作系统"]},{"title":"面向服务的软件工程","url":"/2023/04/01/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/SOA/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1711712728&Signature=GSViIbrz9rSXievJg8IYiw53X78%3D\") ","categories":["面向服务的软件工程"]},{"title":"面向服务的软件工程选择题整理","url":"/2023/04/04/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/SOA/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1711712879&Signature=z6qHLrivHJIvKyCBOL0p9BVjJAI%3D\") ","categories":["面向服务的软件工程"]},{"title":"需求工程","url":"/2022/12/25/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/requirement/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1706532371&Signature=7oPGwYVO2n4W819l1N4yucJ20iw%3D\") ","categories":["需求与商业模式创新"]},{"title":"高精度运算","url":"/2022/06/06/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/","content":"基础数据处理函数void moveFrontZero(string &amp;a){//去除一个字符串的前导0\ta.erase(0,a.find_first_not_of('0'));\tif(a.empty()){        a = \"0\";    }}void align(string &amp;a, string &amp;b){//让两个字符串变成相同的长度，长度小的补0\tint a_size = a.size();\tint b_size = b.size();\tif(a_size &lt; b_size){\t\tfor(int i = 1; i &lt;= b_size - a_size; i++){\t\t\ta = \"0\" + a;\t\t}\t}else{\t\tfor(int i = 1; i &lt;= a_size-b_size; i++){\t\t\tb = \"0\" + b;\t\t}\t}}\n\n高精度加法string add(string addent, string adder){\tmoveFrontZero(addent);\tmoveFrontZero(adder);\tstring answer = \"\";\talign(addent,adder);\tint temp = 0, carry = 0;//temp表示当前对位相加结果，carry表示进位\tfor(int i = addent.size() - 1; i &gt;= 0; i--){\t\ttemp = addent[i] - '0' + adder[i] - '0' + carry;\t\tcarry = temp/10;\t\ttemp %= 10;\t\tanswer = (char)(temp + '0') + answer;\t}\tif(carry){//处理最高位相加可能产生的进位        answer = (char)(carry + '0') + answer;    }\tmoveFrontZero(answer);\treturn answer;}\n\n高精度减法string sub(string subtrahend, string subtractor){//顺序是被减数和减数\tmoveFrontZero(subtrahend);\tmoveFrontZero(subtractor);\talign(subtrahend,subtractor);\tbool is_minus = false;\tif(subtrahend &lt; subtractor){\t\tis_minus = true;\t\tsubtrahend.swap(subtractor);//确保大数减小数\t}\tstring answer = \"\";\tint temp = 0,carry = 0;//temp表示当前对位相减结果，carry表示借位\tfor(int i = subtrahend.size() - 1; i &gt;= 0; i--){\t\tif(subtrahend[i] - carry &lt; subtractor[i]){//被减数不够减的情况\t\t\ttemp = subtrahend[i] - carry + 10 - subtractor[i];\t\t\tcarry = 1;\t\t\tanswer = (char)(temp +'0') + answer;\t\t}else{//被减数够减\t\t\ttemp = subtrahend[i] - carry - subtractor[i];\t\t\tcarry = 0;\t\t\tanswer = (char)(temp +'0') + answer;\t\t}\t}\tmoveFrontZero(answer);\tif(is_minus)answer = \"-\"+answer;\treturn answer;}\n\n高精度乘法（需要依赖高精度加法）乘法的主要思想是把乘法转化为加法进行运算。以下面具体的例子说明：\n\n\n等式（1）​说明，多位数乘一位数，可以直接使用加法完成。\n等式（2）说明，多位数乘形如的数，可以转换成多位数乘一位数来处理。\n等式（3）说明，多位数乘多位数，可以转换为若干个多位数乘形如的数与多位数乘一位数之和。\n因此，多位数乘多位数最终可以全部用加法来实现。\nstring mul(string multiplicand, string multiplier){    //multiplicand表示被乘数，即上面例子中的12345，multiplier是乘数，即上面例子的24    string answer = \"0\";//answer必须初始化为“0”    for (int i = (int) multiplier.length() - 1; i &gt;= 0 ; i--) {        for (char c = '1'; c &lt;= multiplier[i]; c++) {            answer = add(answer, multiplicand);        }        multiplicand = multiplicand + \"0\";    }    moveFrontZero(answer);\treturn answer;}\n\n高精度除法（需要依赖高精度减法）//试商法string div(string dividend, string divisor){\tmoveFrontZero(dividend);\tmoveFrontZero(divisor);\tstring answer = \"\";\tstring reminder = \"\";\treminder.append(dividend,0,divisor.size()-1);//截取被除数从首位到除数位数的前一位\tfor(int i = divisor.size() - 1; i &lt; dividend.size(); i++){\t\treminder = reminder + dividend[i];\t\tmoveFrontZero(reminder);\t\tfor(char j = '9';j &gt;= '0'; j--){\t\t\tstring temp = \"\";\t\t\ttemp = temp + j;\t\t\ttemp = mul(divisor,temp);\t\t\talign(temp,reminder);\t\t\tif(temp &lt;= reminder){\t\t\t\tanswer = answer + j;\t\t\t\treminder = sub(reminder,temp);\t\t\t\tbreak;\t\t\t}\t\t}\t}\t    moveFrontZero(answer);\t//cout  &lt;&lt;  \"reminder=\"  &lt;&lt;  reminder  &lt;&lt;  endl;\treturn answer;}\n\n高精度阶乘（利用高精度减法和乘法实现）string factorial(string a){//高精度阶乘（最大可运行出10000左右的阶乘）    moveFrontZero(a);\tif(a == \"1\"){\t\treturn a;    }\telse \t\treturn mul(a,factorial(sub(a,\"1\")));//即利用递归转化为a*(a-1)!}\n\n","categories":["数据结构与算法"]},{"title":"页面替换算法","url":"/2022/12/20/%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995120&Signature=cVWdk8hLduEeDwv3K5i/TpHb/bw%3D\") ","categories":["操作系统"]},{"title":"第一章 计算机系统漫游","url":"/2022/06/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/","content":"第一章 计算机系统漫游以hello程序的生命周期为例来开始对系统的学习\n#include &lt;stdio.h&gt;int main(){  printf(\"hello, world\\n\");  return 0;}\n\n\n1.1 信息就是位+上下文\nhello.c程序是以字节序列的方式存储在文件中的，大部分计算机系统都用ASCII标准\n\n系统中的所有信息都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。\n1.2 程序被其他程序翻译成不同的格式\nGCC读取hello.c文件并将其翻译为可执行目标文件hello共分为4个阶段，执行这4个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统\n\n\n预处理阶段 ：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序，得到另一个.i文件。\n\n编译阶段 ：编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。\n\n汇编阶段 ：汇编器（as）将hello.s文件翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在hello.o中\n\n链接阶段 ： hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器（ld）就负责处理这种合并。结果就得到hello文件，它是一个可执行目标文件（可执行文件），可以被加载到内存中，由系统执行。\n\n\n1.3 了解编译系统如何工作是大有益处的\n\n优化程序性能\n\n理解链接时出现的错误\n\n避免安全漏洞\n\n\n1.4 处理器读并解释储存在内存中的指令\n1.4.1 系统的硬件组成\n\n总线 ：贯串整个系统的一组电子管道。它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字 ，字中的字节数（字长 ）是一个基本的系统参数，大多数为64位。\n\nI/O设备 ：每个I/O设备都通过一个控制器 或适配器 与I/O总线相连。控制器和适配器的区别主要在于它们的封装方式，控制器是I/O本身或者系统的主印制电路板（主板 ）上的芯片组，适配器是一块插在主板插槽上的卡。\n\n主存 ：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器 （dynamic random access memory，DRAM）芯片组成的；从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。\n\n处理器 ：中央处理单元 （CPU），简称处理器，是解释或执行存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器 （PC）。在任何时候，PC都指向主存中的某条机器语言指令，即含有该条指令的地址。\n\n\n从系统通电开始，直到系统断电，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。\n1.4.2 运行hello程序初始时，在Linux系统中，shell程序执行它的指定，等待输入命令。当在键盘上输入字符串”./hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。\n\n在键盘敲回车键，即结束命令输入后，shell执行一系列将hello目标文件中的代码和数据从磁盘复制到主存。利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从硬盘到达主存，这个步骤如下图所示。\n\n\n一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器指令，将“hello, world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上，该步骤如下图所示。\n\n\n1.5 高速缓存至关重要\n针对处理器和主存之间的差异，系统设计者采用更小更快的存储设备，称为高速缓存存储器 （cache memory，简称为cache或高速缓存），作为暂时的集结区域，存放处理器可能会需要的信息。处理能力强的系统可能会有三级高速缓存：L1、L2和L3使系统获得更大的存储器，同时访问速度更快，原因是利用了高速缓存的局部性 原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。\n\n1.6 存储设备形成层次结构\n每个计算机系统中的存储设备都被组织成了一个存储器层次结构 ，在这个结构中，从上至下，设备的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越便宜。\n\n\n存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。\n1.7 操作系统管理硬件\n在hello例子中，shell和hello程序都没有直接访问键盘、显示器、磁盘或主存，它们依靠操作系统 提供的服务。可以把操作系统看作是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。\n\n操作系统有两个基本功能 ：\n1.防止硬件被失控的应用程序滥用；\n2.向应用程序提供简单一致的机制来控制复杂而又通常大而不同的低级硬件设备。\n操作系统通过几个基本的抽象概念（进程 、虚拟内存 和文件 ）来实现这两个功能。\n\n1.7.1 进程进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以运行多个进程，而每个进程都好像在单独地使用硬件。而并发运行 ，则是说一个进程的指令和另一个进程的指令是交错执行的。一个CPU看上去都像是在并发的执行多个进程，这是通过处理器在进程间切换实现的。操作系统实现这种交错执行的机制称为上下文切换 （上下文是指操作系统保持跟踪进程运行所需的所有状态信息）。下图展示了hello程序运行场景的基本理念。\n\n\n示例场景中有两个并发的进程：shell进程和hello进程。最开始，只有shell进程在运行，即等待命令行上的输入。当让它运行hello程序时， shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传给新的hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给它， shell进程会继续等待下一个命令行输入。\n从一个进程到另一个进程的转换是由操作系统内核 管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用 指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合。\n1.7.2 线程1.一个进程实际上可以由多个称为线程 的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。\n2.因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。\n1.7.3 虚拟内存虚拟内存为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间 。下图是Linux进程的虚拟地址空间，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有的进程来说都是一样的；底部区域存放用户进程定义的代码和数据。\n\n\n\n程序代码和数据   对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。\n\n堆   代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。\n\n共享库   大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。\n\n栈   位于用户虚拟地址空间顶部的是用户栈 ，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每当调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。\n\n内核虚拟内存   地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。\n\n\n虚拟内存运行的基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。\n1.7.4 文件文件就是字节序列。每个I/O设备都可以看成是文件。系统中所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。\n1.8 系统之间利用网络通信\n\n\n对于hello程序，可以用telnet应用在一个远程主机上运行hello程序。假设用本地主机上的telnet客户端连接远程主机上的telnet服务器，在登陆到远程主机并运行shell后的步骤如下图所示。\n\n1.9 重要主题\n1.9.1 Amdahl定律Amadahl定律的主要思想是，当对系统的某部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。\n设系统执行某应用程序需要时间为，系统某部分所需执行时间与该时间的比例为​，该部分性能提升比例为，所以总的执行时间为，所以加速比为\n可以看到，虽然对系统一个主要部分做出重大改进，但获得的系统加速比却远小于这部分的加速比，这就是Amdahl定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。\n1.9.2 并发和并行并发（concurrency）是指一个同时具有多个活动的系统；并行（parallelism）指的是用并发来使一个系统运行得更快。\n下面按照系统层次结构由高到低顺序强调并行的三个层次：\n1. 线程级并发 \n\n\n如下图，多核处理器是将多个CPU（称为“核”）集成到一个集成电路芯片上。下图中的微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中L1高速缓存分为两个部分，一个保存最近取到的指令，另一个放数据。这些核共享更高层次的高速缓存，以及到主存的接口。\n\n\n超线程（有时称为同时多线程）是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器；而其他的硬件部分只有一份，比如执行浮点算数运算的单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。\n多处理器的使用从（1）减少在执行多个任务时模拟并发的需要；（2）使应用程序运行的更快 两个方面提高系统性能。\n2. 指令级并行 \n在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行 。\n在流水线 中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。\n如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量 处理器。\n3. 单指令、多数据并行 \n在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据 ，即SIMD并行。\n提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。\n可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC就支持向量数据类型。\n1.9.3 计算机系统中抽象的重要性\n\n指令集架构 提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上；\n文件 是对I/O设备的抽象；\n虚拟内存 是对程序存储器的抽象；\n进程 是对一个正在运行的程序的抽象；\n虚拟机 提供对整个计算机的抽象，包括操作系统、处理器和程序\n1.10 小结\n计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件。\n处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。\n操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：\n\n文件是对I/O设备的抽象；\n\n虚拟内存是对主存和磁盘的抽象；\n\n进程是处理器、主存和I/O设备的抽象。\n\n\n最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。\n","categories":["CSAPP笔记"]},{"title":"第三章 程序的机器级表示","url":"/2022/06/06/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","content":"第三章 程序的机器级表示计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。\n3.1 程序编码\n假设一个C程序，有两个文件p1.c和p2.c。用Unix命令行编译这些代码：\nlinux&gt; gcc -0g -o p p1.c p2.c\n\n\n\n命令gcc指的就是GCC C编译器。因为这是Linux上默认的编译器，也可以简单地用cc来启动它。\n编译选项-0g告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。\n实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项-01或-02指定）被认为是较好的选择。\n\n实际上gcc命令调用了一整套的程序，将源代码转化为可执行代码：\n\n首先， C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏。\n其次，编译器产生两个源文件的汇编代码，名字分别为p1.s和p2.s。\n接下来，汇编器会将汇编代码转化成二进制目标代码文件p1.o和p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。\n最后，链接器将两个目标代码文件与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件p（由命令行指示符-o p指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。\n\n\n\n3.1.1 机器级代码对于机器级编程来说，其中两种抽象尤为重要：\n\n由指令集体系结构或指令集架构（Instruction Set Architecture, ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA, 包括x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。\n机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。\n\nx86-64的机器代码中一些通常对C语言程序员隐藏的处理器状态都是可见的：\n\n程序计数器（通常称为“PC”，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址。\n整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言中的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。\n条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，例如用来实现if和while语句。\n一组向量寄存器可以存放一个或多个整数或浮点数值。\n\n机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。\n程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用malloc库函数分配的）。程序内存用虚拟地址来寻址。\n3.1.2 代码示例1. 编译器\nC语言代码文件mstore.c中包含如下的函数定义\nlong mult2(long, long);void multstore(long x,long y,long *dest){  long t = mult2(x,y);  *dest = t;}\n\n\n在命令行上运行linux&gt; gcc -0g -S mstore.c产生一个汇编文件mstore.s：\n         .file   \"010-mstore.c\"         .text            .globl  multstore         .type   multstore,@fuctionmultstore:                  pushq   %rbx         movq    %rbx, %rbx         call    mult2         movq    %rax, (%rbx)         popq    %rbx         ret         .size   multstore, .-multstore         .ident  \"GCC:(Ubuntu 4.8.1-2ubuntu1~12.04)4.8.1\"         .section       .note.GNU-stack,\"\",@progbits     \n\n\n所有以“.”开头的行都是指导汇编器和连接器工作的伪指令，通常可以忽略这些行。为了更清楚地说明汇编代码，用这样一种格式来表示汇编代码，它省略了大部分伪指令，但包括行号和解释性说明。对于本例该代码如下：\nvoid multstore(long x, long y, long *dest)x in %!r(MISSING)di, y in %!r(MISSING)si, dest in %!r(MISSING)dxmultstore:    pushq     %rbx             Save %!r(MISSING)bx    moveq     %rbx, %rbx       Copy dest to %!r(MISSING)bx    call      mult2            Call mult2(x,y)    movq      %rax, (%rbx)     Store result at *dest    popq      %rbx             Restore %!r(MISSING)bx    ret                        Return\n\n\n汇编代码相比C语言有以下特点：\n\n有许多不同类型的整型数据类型，它们存储时不区分符号和无符号\n指针是以简单的数字的形式保存在计算机中的\n浮点数以和整型数据完全不同的方式进行处理，并且使用完全不同的寄存器组\n程序本身是一系列字节\n机器级别并不存在类似数组和结构这样的基本数据类型，它们是由编译器构成的\n汇编语言中的每条语言能做的都非常有限\n变量所有名称在汇编代码级别完全丢失了，变成了寄存器和内存中的某个位置\n\n2.汇编器\n运行gcc -Og -c mstore.c来进行编译和汇编，会生成二进制文件mstore.o，它是对一系列指令的编码，机器直接执行这些字节序列，而对源代码一无所知。\n可以通过反汇编器来将机器代码转化为类似汇编代码的格式，在Linux中，运行objdump -d mstore.o，可以得到：\nDisassembly of function multstore in binary file mstore.o0000000000000000 &lt;multstore&gt;Offset   Byte                     Equivalent assembly language    0:   53                       push      %rbx    1:   48 89 d3                 move      %rbx, %rbx    4:   e8 00 00 00 00           callq     9 &lt;multstore+0x9&gt;    9:   48 89 03                 mov       %rax, (%rbx)    c:   5b                       pop      %rbx    d:   c3                       retq\n\n\n最左侧一栏是对应的字节地址，中间是每个指令的编码，右侧是等价的汇编语言。其中一些关于机器代码和它的反汇编表示的特性值得注意：\n\nx86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。\n设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq  %rbx是以字节值53开头的。\n反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。\n反汇编器使用的指令命名规则与GCC 生成的汇编代码使用的有些细微的差别。在示例中，它省略了很多指令结尾的‘q’。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call和ret指令添加了‘q’后缀，同样，省略这些后缀也没有问题。\n\n3.链接器\n生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数。假设在文件main.c中有下面这样的函数：\n#include &lt;stdio.h&gt;void multstore(long, long ,long*)int main(){  long d;  multstore(2, 3, &amp;d);  printf(\"2 * 3 --&gt; %ld\\n\",d);  return 0;}long mult2(long a, long b){  long s = a * b;  return s;} \n\n\n然后运行命令linux&gt; gcc -0g -o prog main.c mstore.c将main.c和mstore.c链接起来，并添加启动和终止程序的代码，以及用来与操作系统交互的代码生成可执行代码，最终生成可执行文件prog。通过对其反汇编，可以得到如下内容：\nDisassembly of function sum multstore binary file prog0000000000400540 &lt;multstore&gt;400540:   53                       push      %rbx400541:   48 89 d3                 move      %rbx, %rbx400544:   e8 42 00 00 00           callq     40058b &lt;mult2&gt;400549:   48 89 03                 mov       %rax, (%rbx)40054c:   5b                       pop       %rbx40054d:   c3                       retq40054e:   90                       nop40054f:   90                       nop\n\n\n可以看出，这段代码与mstore.c反汇编产生的代码的区别有：\n\n左边列出的地址不同，链接器将这段代码的地址移到了一段不用的地址范围中\n链接器填上了callq指令调用函数mult2需要使用的地址（第5行）。链接器的任务之一就是为函数调用找到匹配的函数可执行代码的位置。\n多了两行代码（第9和10行）。插入这些指令是为了使函数代码变为16字节，使得就存储器系统性能而言，能更好地放置下一个代码块。\n\n3.2 数据格式\n\n大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和movq（传送四字）。注意，汇编代码使用后缀‘l’来表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。\n3.3 访问信息\n一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。这些寄存器都用来存储整数数据和指针，名字都以%r开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。\n\n\n当指令以寄存器作为目标时，对于生成小于8字节结果的指令，对于寄存器中剩下的字节会怎么样有两条规则：生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0。\n有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。\n3.3.1 操作数指示符大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据可以以常数形式给出，或是从寄存器或内存中读出，结果可以存放在寄存器或内存中。\n\n各种不同的操作数的可能性被分为三种类型：\n1.立即数（immediate），用来表示常数值。书写方式是‘$’后跟一个用标准C表示法的整数。不同指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。\n2.寄存器（register），表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数。用符号表示任意寄存器，用引用表示它的值。\n3.内存（memory）引用，根据计算出来的地址（通常称为有效地址）访问某个内存位置。用符号表示对存储在内存中从地址开始的个字节值的引用，通常省去下标。\n有多种不同的寻址模式，允许不同形式的内存引用。是最常用的形式。这个引用有四个组成部分：一个立即数偏移，一个基址寄存器，一个变址寄存器和一个比例因子且必须是1、2、4或8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为。其他形式都是这种通用形式的特殊情况。\n3.3.2 数据传送指令最频繁的指令是将数据从一个位置复制到另一个位置的指令。\n\n\n源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。\n大多数情况中， MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。\n在下面的MOV指令示例中，第一个是源操作数，第二个是目的操作数。\nmovl $0x4050,%eax                Immediate--Register, 4 bytesmovw %bp,%sp                     Register--Register,  2 bytesmovb (%rbi,%rcx),%al             Memory--Register,    1 bytemovb $-17,(%rsp)                 Immediate--Memory,   1 bytemovq %rax,-12(%rbp)              Register--Memory,    8 bytes\n\n\nmovabsq是处理64位立即数数据的。常规的movq指令只能以表示32位补码数字的立即数作为源操作数，然后将其符号拓展为64位放到目的位置。而movabsq能以64位立即数为源操作数，并且只能以寄存器作为目的。\n下图的数据移动指令在将较小的源值复制到较大的目的时使用。每条指令的最后两个字符都是大小指示符：第一个字符指定源的大小，第二个指明目的的大小。\n\n\n3.3.3 数据传送示例对于下面的C代码\nlong exchange(long *xp, long y){   long x = *xp;   *xp = y;   return x;}\n\n\n对应的汇编代码如下，其中寄存器%rdi和%rsi分别存放参数xp和y\nlong exchange(long *xp, long y)xp in %!r(MISSING)di, y in %!r(MISSING)siexchage:   movq     (%rdi), %rax            Get x at xp. Set as return value.   movq     %rsi, (%rdi)            Store y at xp.   ret                              Return.\n\n\n关于这段汇编代码有两点值得注意：\n\nC语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。\n像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。\n\n3.4.4 压入和弹出栈数据栈是一种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则。通过push操作把数据压入栈中，通过pop操作删除数据；它具有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。\n\n\n栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为栈顶。\npushq指令的功能是把数据压入到栈上，而popq指令是弹出数据。这些指令都只有一个操作数一一压入的数据源和弹出的数据目的。\n将一个四字值压人栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，指令pushq %rbp的行为等价于下面两条指令：\nsubq $8, %rsp               Decrement stack pointermovq %rbp, (%rsp)           Store %!r(MISSING)bp on stack\n\n\n弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8。因此，指令popq %rax等价于下面两条指令：\n\n\n图中前两栏给出的是，当%rsp为0x108，%rax为0x123时，执行指令pushq %rax的效果。首先%rsp会减8，得到0x100，然后会将0x123存放到内存地址0x100处。第三栏说明的是在执行完pushq后立即执行指令popq %rdx的效果。先从内存中读出值0x123，再写到寄存器%rdx中，然后，寄存器%rsp的值将增加回到0x108。如图中所示，值0x123仍然会保持在内存位置0xl00中，直到被覆盖（例如被另一条入栈操作覆盖）。无论如何，%rsp指向的地址总是栈顶。\n3.4 算术和逻辑操作\n下图中的指令类（除leaq外）有各种带不同大小操作数的变种。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。\n\n\n3.4.1 加载有效地址加载有效地址指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。这条指令可以为后面的内存引用产生指针，也可以简洁地描述普通的算术操作，例如：\nlong scale(long x, long y, long z){  long t = x + 4 * y + 12 * z;  return t;} \n\n\n编译时，该函数的算术运算以三条leap指令实现：\n  long scale(long x, long y, long z)  x in %!r(MISSING)di, y in %!r(MISSING)si, z in %!r(MISSING)dxscale:  leaq    (%rdi,%rsi,4), %rax       x + 4*y  leaq    (%rdx,%rdx,2), %rdx       z + 2*z = 3*z  leaq    (%rax,%rdx,4), %rax       (x+4*y) + 4*(3*z) = x + 4*y + 12*z  ret\n\n\nleaq指令能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。\n3.4.2 一元和二元操作对于一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。例如incq(%rsp)会使栈顶的8字节元素加1。\n而二元操作中，第二个操作数既是源又是目的。这种语法类似于C语言中的x-=y，不过源操作数是第一个，目的操作数是第二个。第一个操作数可以是立即数、寄存器或内存位置，第二个操作数可以是寄存器或内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存中读出值，执行操作，再把结果写回内存。\n例：假设下面的值存放在指定的内存地址和寄存器中：\n\n\n给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值：\n\n\n\n地址\n目的\n值\n\n\n\naddq %rcx, (%rax)\n0x100\n0x100\n\n\nsubq %rdx, 8(%rax)\n0x108\n0xA8\n\n\nimulq $16, (%rax,%rdx,8)\n0x118\n0x110\n\n\nincq 16(%rax)\n0x110\n0x14\n\n\ndecq %rcx\n%rcx\n0x0\n\n\nsubq %rdx, %rax\n%rax\n0xFD\n\n\n3.4.3 移位操作移位操作首先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器%cl中（只允许这个特定的寄存器作为操作数）。\n例如，下面的C语言代码：\nlong shift_left4_rightn(long x, long n){  x &lt;&lt;= 4;  x &gt;&gt;= n;  return x;}  \n\n\n其对应的汇编代码为：\n  long shift_left4_rightn(long x, long n)  x in %!r(MISSING)di, n in %!r(MISSING)sishift_left4_rightn:  movq      %rdi, %rax      Get x  salq      $4, %rax        x &lt;&lt;= 4  movl      %esi, %ecx      Get x (4 bytes)  sarq      %cl, %rax       x &gt;&gt;= n \n\n\n3.4.4 算术操作示例C语言代码：\nlong arith(long x, long y, long z){  long t1 = x ^ y;  long t2 = z * 48;  long t3 = t1 &amp; 0x0F0F0F0F;  long t4 = t2 - t3;  return t4;\n\n\n汇编代码：\nlong arith(long x, long y, long z)x in %!r(MISSING)di, y in %!r(MISSING)si, z in %!r(MISSING)dxarith:  xorq     %rsi, %rdi                 t1 = x ^ y  leaq     (%rdx, %rdx, 2), %rax      3 * z  salq     $4, %rax                   t2 = 16 * (3*z) = 48*z  andl     $252645135, %edi           t3 = t1 &amp; 0x0F0F0F0F  subq     %rdi, %rax                 Return t2 - t3  ret  \n\n\n3.4.5 特殊的算术操作两个64位有符号或无符号整数相乘得到的乘积需要128位来表示，x86-64指令集对128位（16字节，8字）数的操作提供有限的支持。\n\n\nimulq可以用于两个不同的乘法的操作，其中一种是从两个64位操作数产生64位乘积的双操作数指令；另一种是计算两个64位的全128位补码乘积的单操作数指令。\n例如，在小端机器上运行下面的C代码：\n#include &lt;inttypes.h&gt;typedef unsigned __int128 uint128_t;void store_uprod(uint128_t *dest, uint64_t x, uint64_t y){  *dest = x * (uint128_t) y;}\n\n\nGCC生成的汇编代码为：\nvoid store_uprod(uint128_t *dest, uint64_t x, uint64_t y)dest in %!r(MISSING)di, x in %!r(MISSING)si, y in %!r(MISSING)dxstore_uprod:    movq        %rsi, %rax            Copy x to multiplicand    mulq        %rdx                  Multiply by y    movq        %rax, (%rdi)          Store lower 8 bytes at dest    movq        %rdx, 8(%rdi)         Store upper 8 bytes at dest+8    ret \n\n\n对于除法和取模操作，由单操作数除法指令提供。有符号除法指令idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。\n对于更普遍的64位的被除数除法而言，被除数被存放在%rax中，%rdx的位应全设置为0（无符号运算）或者%rax的符号位（有符号运算）。后面这个操作可以用指令cqto完成，这个指令不需要操作数，它隐含读出%rax的符号位，并将它复制到%rdx的所有位。\n例如下面计算两个64位有符号数的商和余数的C语言代码：\nvoid remdiv(long x, long y, long *qp, long *rp){  long q = x/y;  long r = x%y;  *qp = q;  *rp = r;} \n\n\n汇编代码为：\nvoid remdiv(long x, long y, long *qp, long *rp)x in %!r(MISSING)di, y in %!r(MISSING)si, qp in %!r(MISSING)dx, rp in %!r(MISSING)cxremdiv:  movq       %rdx, %r8           Copy qp  movq       %rdi, %rax          Move x to lower 8 bytes of dividend  cqto                           Sign-extend to upper 8 bytes of dividend  idivq      %rsi                Divide by y  movq       %rax, (%r8)         Store quotient at qp  movq       %rdx, (%rcx)        Store remainder at rp  ret        \n\n\n在上述代码中，必须首先把参数qp保存到另一个寄存器中（第4行），因为除法操作要使用参数寄存器%rdx。接下来，第5~6行准备被除数，复制并符号扩展x。除法之后，寄存器%rax中的商被保存在qp（第8行），而寄存器%rdx中的余数被保存在rp（第9行）。\n3.5 控制\n机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。\n与数据相关的控制流是实现有条件行为的更一般和更常见的方法。\n用jump指令可以改变一组机器代码指令的执行顺序，jump指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种低级机制基础之上的指令序列，来实现C语言的控制结构。\n3.5.1 条件码除了整数寄存器，CPU还维护一组单个位的条件码寄存器，最常用的条件码有：\n\nCF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。\nZF：零标志。最近的操作得出的结果为0。\nSF：符号标志。最近的操作得到的结果为负数。\nOF：溢出标志。最近的操作导致一个补码溢出（正溢出或负溢出)。\n\n除了leaq之外，图3-10（3.4节首图）中列出的所有指令都会设置条件码。对于逻辑操作，进位标志和溢出标志会设置成0。对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为0。INC和DEC指令会设置溢出和零标志，但不会改变进位标志。\n除了上述指令，还有如下图所示的两类指令，它们只设置条件码而不改变任何其他寄存器\n\n\nCMP和SUB指令、TEST和AND指令行为一样，除了只设置条件码而不更新寄存器。对于CMP指令，如果两个数一样，会将零标志设置为1；对于TEST指令的典型用法是检查数字的正负（testq %rax, %rax），或其中一个操作数是一个掩码，用来指示哪些位应该被测试。\n3.5.2 访问条件码常用的条件码使用功能有3种：\n\n可以根据条件码的某种组合，将一个字节设置为0或者1\n可以条件跳转到程序的某个其他的部分\n可以有条件地传送数据\n\n对于第一种情况，由下图中的SET指令实现\n\n\n一个计算C语言表达式a &lt; b的典型指令序列为：（这里a和b都是long类型）\nint comp(data_t a, data_t b)a in %!r(MISSING)di, b in %!r(MISSING)sicomp:  cmpq     %rsi, %rdi       Compare a:b  注意比较顺序  setl     %al              Set low-order byte of %!e(MISSING)ax to 0 or 1  movzbl   %al, %eax        Clear reset of %!e(MISSING)ax (and rest of %!r(MISSING)ax)  movzbl指令不光会把%!e(MISSING)ax的高3个字节清零，还会把整个寄存器%!r(MISSING)ax的高4个字节都清零。  ret\n\n\n3.5.3 跳转指令\n\njmp指令是无条件跳转。可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。\n汇编语言中，直接跳转是给出一个编号作为跳转目标，例如jmp .L1，间接跳转是“*”后面跟一个操作数指示符，例如jmp *%rax用寄存器%rax中的值作为跳转目标，jmp *(%rax)以%rax中的值作为读地址，从内存中读出跳转目标。\n其他跳转指令都是有条件的——它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。\n3.5.4 跳转指令的编码跳转指令最常用的编码是PC相对的，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之差作为编码。\n下面是一个PC相对寻址的例子：\n  movq          %rdi, %rax  jmp           .L2.L3:  sarq          %rax.L2:  testq         %rax, %rax  jg            .L3  rep; ret\n\n\n汇编器产生的反汇编版本为：\n0:     48 89 f8         mov      %rdi, %rax3:     eb 03            jmp      8 &lt;loop+0x8&gt;5:     48 d1 f8         sar      %rax8:     48 85 c0         test     %rax, %raxb:     7f f8            jg       5 &lt;loop+0x5&gt;d:     f3 c3            repz retq\n\n\n右边反汇编器产生的注释中，第2行中跳转指令的跳转目标指明为0x8，第5行中跳转指令的跳转目标是0x5（反汇编器以十六进制格式给出所有的数字）。不过，观察指令的字节编码，会看到第一条跳转指令的目标编码（在第二个字节中）为0x03。把它加上0x5，也就是下一条指令的地址，就得到跳转目标地址0x8，也就是第4行指令的地址。\n类似地，第二个跳转指令的目标用单字节、补码表示编码为0xf8（-8）。将这个数加上0xd（13）即第6行指令的地址，得到0x5, 即第3行指令的地址。\n当执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。\n例1 下面je指令的目标是什么\n4003fa: 74 02           je     XXXXXX     //0x4003fc + 0x02 = 0x4003fe4003fc: ff d0           callq  *%rax\n\n\n例2 下面je指令的目标是什么\n40042f: 74 f4           je XXXXXX        //0x400431 + 0xf4 (-12) = 0x400425400431: 5d              \n\n\n例3 ja和pop指令的地址是多少\nX1: 77 02           ja   400547         //X1 + 2 = X2,             X1=400543X2: 5d              pop  %rbp           //X2 + 0x02 = 0x400547,    X2=400545\n\n\n3.5.5 用条件控制来实现条件分支","categories":["CSAPP笔记"]},{"title":"第二章 信息的表示和处理","url":"/2022/06/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","content":"第二章 信息的表示和处理2.1 信息存储\n大多数计算机使用8 位的块，或者字节 （byte）, 作为最小的可寻址的内存单位。\n机器级程序将内存视为一个非常大的字节数组，称为虚拟内存 （virtual memory） 。\n内存的每个字节都由一个唯一的数字来标识，称为它的地址 （address）。\n所有可能地址的集合就称为虚拟地址空间 （virtual address space），这个虚拟地址空间只是一个展现给机器级程序的概念性映像。\n2.1.1 十六进制表示法十六进制表示、十六进制和十进制的互相转换。\n2.1.2 字数据大小每台计算机都有一个字长 （word size）， 指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为位的机器而言，虚拟地址的范围为，程序最多访问个字节。\n32 位字长限制虚拟地址空间为4 千兆字节（写作4GB，1G=）, 也就是说，刚刚超过字节。扩展到64 位字长使得虚拟地址空间为16EB, 大约是字节。\n\n可移植性： 许多程序员假设一个声明为int 类型的程序对象能被用来存储一个指针。这在大多数32 位的机器上能正常工作，但是在一台64 位的机器上却会导致问题。\n2.1.3 寻址和字节顺序对于跨越多字节的程序对象，必须建立两个规则：这个对象的地址是什么 ，以及在内存中如何排列这些字节 。\n在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。\n某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，称为小端法 （little endian）；而另一些机器则按照从最高有效字节到最低有效字节的顺序存储，称为大端法 （big endian）。\n以int类型的变量x为例，假设其位于地址0x100处，它的16进制值为0x01234567。地址范围0x100~0x103的字节顺序依赖于机器的类型：\n\n\n在有些时候，字节顺序会成为问题：\n\n是在不同类型的机器之间通过网络传送二进制数据时， 一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关千字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。\n\n当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在阅读由反汇编器生成的机器级代码时。\n\n当编写规避正常的类型系统的程序时。\n\n\n打印程序对象的字节表示： \n#include &lt;stdio.h&gt;typedef unsigned char *byte_pointer;//用typedef将数据类型byte_pointer定义为一个指向类型为unsigned char的对象的指针void show_bytes(byte_pointer start,size_t len){//输入参数是一个字节序列的地址，用一个字节指针和一个字节数来表示。  size_t i;  for(i = 0;i &lt; len;i++){    printf(\"%.2x\",start[i]);//表示整数必须用至少两个数字的十六进制格式输出。  }  printf(\"\\n\");}//打印出每个以十六进制表示的字节。void show_int(int x){//&amp;x被强制类型转换为\"unsigned char *\"，即把这个指针看成指向一个字节序列的对象  show_bytes((byte_pointer) &amp;x,sizeof(int));//使用sizeof增加可移植性}void show_float(float x){  show_bytes((byte_pointer) &amp;x,sizeof(float));}void show_pointer(void *x){  show_bytes((byte_pointer) &amp;x,sizeof(void *));}void test_show_bytes(int val){  int ival = val;  float fval = (float) ival;  int *pval = &amp;ival;  show_int(ival);  show_float(fval);  show_pointer(pval);} \n\n\n2.1.4 表示字符串C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。\n在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。\n\n2.1.5 表示代码对于下面的C函数\nint sum(int x,int y){  return x+y;}\n\n\n在不同机器上生成的字节表示的机器代码是不同的：\nLinux 32    55 89 e5 8b 45 0c 03 45 08 c9 c3Windows     55 89 e5 8b 45 0c 03 45 08 5d c3Sum         81 c3 e0 08 90 02 00 09Linux 64    55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3\n\n\n不同的机器类型使用不同的且不兼容的指令和编码方式，二进制代码是不兼容的。\n计算机系统的一个基本概念是，从机器的角度来看，程序仅仅只是字节序列。\n2.1.6 布尔代数简介\n2.1.7 C语言中的位运算C语言使用的符号和布尔运算中使用的符号相同：|就是或，&amp;就是与，~就是取反，^就是异或\n位级运算的一个常见用法就是实现掩码 运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。例如：掩码0xFF（最低的8 位为1）表示一个字的低位字节。位级运算x&amp;0xFF生成一个由x的最低有效字节组成的值，而其他的字节就被置为0 。比如，对于x=0x89ABCDEF其表达式将得到0x000000EF\n2.1.8 C语言中的逻辑运算C语言中的逻辑运算符||、&amp;&amp;和!分别对应于命题逻辑中的OR、AND和NOT运算。\n逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或0，分别表示结果为TRUE或者FALSE。例如：\n\n\n2.1.9 C语言中的移位运算对于一个位表示为的操作数\n左移运算： x&lt;&lt;k生成位表示为的值。即向左移动位，丢弃最高的位，并在右端补个0。\n右移运算： x&gt;&gt;k，分为逻辑右移 和算术右移 。逻辑右移在左端补个0，得到结果是；算术右移在左端补个最高有效位的值，得到的结果是。\n\n\nC 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移，但是，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。\nJava对于如何进行右移有明确的定义，x&gt;&gt;k会将x进行算术右移，而x&gt;&gt;&gt;k会对x进行逻辑右移。\n对于一个由位组成的数据类型，当移动位时，实际位移量是通过计算得到的。例如，假设数据类型int为\nint      lval = 0xFEDCBA98  &lt;&lt; 32; //0xFEDCBA98int      aval = 0xFEDCBA98  &lt;&lt; 36; //0xFFEDCBA9unsigned uval = 0xFEDCBA98u &gt;&gt; 40; //0x00FEDCBA\n\n\n2.2 整数表示\n\n2.2.1 整数数据类型\n\n\nC数据类型\n32位\n64位\n\n\n\n[signed]char\n\n\n\n\nunsigned char\n\n\n\n\nshort\n\n\n\n\nunsigned short\n\n\n\n\nint\n\n\n\n\nunsigned long\n\n\n\n\nlong\n\n\n\n\nunsigned long\n\n\n\n\nint32_t\n\n\n\n\nuint_t\n\n\n\n\nint64_t\n\n\n\n\nuint64_t\n\n\n\n\nC和C++都支持有符号数（默认）和无符号数，Java只支持有符号数。\n2.2.2 无符号数的编码无符号数编码的定义： 对于向量：\n\n位所能表示的值的范围为：最小是0，最大是\n2.2.3 补码编码补码编码的定义： 对于向量：\n\n位所能表示的值的范围为：最小是，最大是\n\n2.2.4 有符号数和无符号数之间的转换补码转换为无符号数： 对满足的有：\n\n无符号数转换为补码： 对满足的有：\n\n的表示可以通过把 的反码加1得到，即“ 取反加1 ”。 （无论是负数转换为无符号数，还是无符号转换为负数都适用）\n2.2.5 C语言中的有符号数与无符号数显式强制类型转换：\nint tx,ty;unsigned ux,uy;tx = (int) ux;uy = (unsigned) ty;\n\n\n隐式类型转换：\nint tx,ty;unsigned ux,uy;tx = ux; //转换为有符号数uy = ty; //转换为无符号数\n\n\n在32位机器上运行以下代码： \nint x = -1;//1111 1111 1111 1111 1111 1111 1111 1111,0xFFFF FFFFunsigned u = 2147483648; //2^31,1000 0000 0000 0000 0000 0000 0000 0000,0x8000 0000printf(\"x = %u = %d\\n\",x,x); //x = 429497295 = -1printf(\"u = %u = %d\\n\",u,u); //u = 2147483648 = -2147483648\n\n\n2.2.6 拓展一个数字的位表示无符号数的零拓展： 定义宽度为的位向量和宽度为的位向量，其中。则。\n补码数的符号拓展： 定义宽度为的位向量和宽度为的位向量，其中。则。\n2.2.7 截断数字int x = 53191; //0000 0000 0000 0000 1100 1111 1100 0111short sx = (short) x; //-12345int y = sx; //-12345    12345-&gt;0011 0000 0011 1001\n\n\n截断无符号数： 令等于位向量，而是将其截断为位的结果：。令,。则。\n截断补码数值： 令等于位向量，而是将其截断为位的结果：。令,。则。\n2.2.8 关于有符号数与无符号数的建议**/* WARNING: This is buggy code. */** float sum_elements(float a[],unsigned length){  int i;  float result = 0;    for(i = 0;i &lt;= lenght-1;i++){    result += a[i];  }  return result;}\n\n\n当参数length等于0时，运行上面的代码应该返回0.0，可实际上运行时会遇到一个内存错误。\n因为参数length是无符号的，计算0-1将使用无符号运算，这等价于模数加法。结果得到。同样使用无符号数比较，而因为任何数都小于等于，所以总是为真，因此代码将试图访问数组a的非法元素。\n2.3 整数运算\n2.3.1 无符号加法无符号数加法（ ）： 对满足的和有：正常溢出\n检测无符号数加法中的溢出： 对在范围中的和，令。则对计算，当且仅当（或等价地）时，发生了溢出。\n无符号数求反：对满足的任意，其位的无符号逆元由下式给出：\n\n2.3.2 补码加法补码加法： 对满足的整数和，有：\n正溢出正常负溢出\n\n\n检测补码加法中的溢出： 对满足的和，令。当且仅当，但时，计算发生了正溢出。当且仅当，但时，计算发生了负溢出。\n2.3.3 补码的非补码的非： 对满足的，其补码的非由下式给出\n\n补码非的位级表示： （1）对每一位求补，再对结果加1（取反加1）\n\n\n（2）设是最右边的1的位置（从右往左数的第一个1），因而的位级表示形如，这个值的非写成二进制格式就是。也就是对位左边的所有位取反。\n2.3.4 无符号乘法无符号数乘法： 对满足的和有：\n\n2.3.5 补码乘法补码乘法： 对满足的和有：\n\n无符号和补码乘法的位级等价性： 给定长度为的位向量和，用补码形式的位向量表示来定义整数和：。用无符号形式的位向量表示来定义非负整数和：。则\n\n2.3.6 乘以常数乘以2的幂： 设为位模式表示的无符号整数。那么，对于任何，都认为给出了的位的无符号表示，这里右边增加了个\n与2的幂相乘的无符号乘法： C变量x和k有无符号数值和，且，则C表达式x&lt;&lt;k产生数值。\n与2的幂相乘的补码乘法： C变量x和k有补码值和无符号数值，且，则C表达式x&lt;&lt;k产生数值。\n由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况。例如对于表达式x*14，编译器会将其重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)或(x&lt;&lt;4)-(x&lt;&lt;1)。\n2.3.7 除以2的幂除以2的幂的无符号除法： C变量x和k有无符号数值和，且，则C表达式x&gt;&gt;k产生数值。\n\n除以2的幂的补码除法，向下舍入： C变量x和k有补码值和无符号数值，且，则当执行算术移位时，C表达式x&gt;&gt;k产生数值。\n\n除以2的幂的补码除法，向上舍入： C变量x和k有补码值和无符号数值，且，则当执行算术移位时，C表达式(x+(1&lt;&lt;k)-1)&gt;&gt;k产生数值。\n\n对于使用算术右移的补码机器，C表达式(x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k将会计算数值。\n\n写一个函数div16，对于整数参数x返回x/16的值。函数中不能使用除法、模运算、乘法、任何条件语句、任何比较运算符或任何循环。假设数据类型int是32位长，使用补码表示，右移是算术右移。\n\n/* 利用表达式x&gt;&gt;31产生一个字，如果x是负数，这个字为全1，否则为全0。   通过掩码屏蔽掉适当的位就可以得到期望的偏置值 */int div16(int x){  /* Compute bias to be either 0(x &gt;=0) or 15(x &lt; 0) */  int bias = (x&gt;&gt;31) &amp; 0xF;  return (x+bias) &gt;&gt;4;}\n\n\n2.4 浮点数\n浮点数对形如的有理数进行编码。\n2.4.1 二进制小数考虑一个形如\n\n的表示法，其中每个二进制数字，或者称为位，的取值范围是0和1，如下图所示。这种表示方法表示的数定义如下：\n\n\n\n2.4.2 IEEE浮点表示IEEE浮点数标准用的形式来表示一个数：\n\n符号： 决定这数是负数（）还是正数（），而对于数值0的符号位解释作为特殊情况处理\n\n尾数： 是一个二进制小数，它的范围是，或者是\n\n阶码： 的作用是对浮点数加权，这个权重是2的次幂（可能是负数）\n\n\n将浮点数的位表示划分为三个字段，分别对这些值进行编码：\n\n一个单独的符号位直接编码符号\n\n位的阶码字段exp=编码阶码\n\n位小数字段frac=编码尾数，但是编码出来的值也依赖于阶码字段的值是否等于0\n\n\n在单精度浮点格式中，s、exp和frac字段分别为位、 位和 位 ，得到一个32位的表示。在双精度浮点格式中，s、exp和frac字段分别为位、 位和 位 ，得到一个64位的表示。\n\n\n给定位表示，根据exp的值，被编码的值可以分成三种不同的情况：\n\n\n情况1：规格化的值 \n当exp的位模式既不全为0，又不全为1时，都属于这类情况。在这种情况中，阶码字段被解释为以偏置形式表示的有符号整数。也就是说，阶码的值是，其中是无符号数，其位表示为，而是一个等于（单精度是127，双精度是1023） 的偏置量。由此产生指数的取值范围，对于单精度是 ，而对于双精度是 。\n小数字段frac被解释为描述小数值，其中，其二进制表示为，也就是二进制小数点在最高有效位的左边。尾数定义为。这种方式也叫隐含的以1开头 的表示，因为可以把看成一个二进制表达式为的数字。实际上是用23位来表示一个24位的数字。\n情况2：非规格化的值 \n当阶码域全为0时，所表示的数是非规格化的形式。在这种情况下， 阶码值是（单精度是 ，双精度是 ），而尾数的值是，也就是小数字段的值，没有隐含的开头的1。\n情况3：特殊值 \n这一类数值是当阶码域全为1时出现的。当小数域全为0时，得到的值表示无穷，当时是正无穷，当时是负无穷。当小数域为非0时，表示。\n2.4.3 数字示例\n\n2.4.4 舍入\n向偶数舍入也被称为向最接近的值舍入，是默认的方式，试图找到一个最接近的匹配值。它将数字向上或者向下舍入，使得结果的最低有效数字是偶数。\n其他三种方式产生实际值的确界。向零舍入方式把正数向下舍入，把负数向上舍入，得到值，使得。向下舍入方式把正数和负数都向下舍入，得到值，使得。向上舍入方式把正数和负数都向上舍入，得到值，满足。\n对于向偶数舍入来讲，它最大的作用是在统计时使用。向偶数舍入可以让我们在统计时，将舍入产生的误差平均，从而尽可能的抵消 。而其它三种方式在这方面都是有一定缺陷的，向上和向下舍入会造成值的偏大或偏小。而对于向零舍入来讲，如果全是正数的时候则会造成结果偏小，全是负数的时候则会造成结果偏大。\n向偶数舍入规则 ：例如有效数字超出规定数位的多余数字是1001，它大于超出规定最低位的一半（即0.5），故最低位进1。如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数）即可。对于多余数字是1000（正好是最低位一半）的特殊情况，若最低位为0则舍掉多余位，最低为1则进位1，使得最低位仍为0（偶数）。 \n\n\n\n舍入前\n舍入后（舍入到最接近的二分之一）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4.5 浮点运算\n浮点加法不具有结合性。 例如，(3.14+1e10)-1e10结果为0.0，而3.14+(1e10-1e10)结果为3.14。\n\n浮点加法满足单调性： 如果，那么对于任何及的值，除了，都有。无符号或补码加法不具有这个性质。\n\n浮点乘法是可交换的，不具有结合性，在加法上不具有分配性，满足单调性，且只要 ，就有 。\n\n\n2.4.6 C语言中的浮点数\n所有的C语言版本提供了两种不同的浮点数据类型：float和double。在支持IEEE浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。\n\n这类机器使用向偶数舍入的舍入方式。\n\n因为C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍入方式或者得到诸如、、或者之类的特殊值。\n\n可以通过引入库函数math.h定义程序常数INFINITY和NAN。\n\n从float或double转换成int时，值会向零舍入。进一步来说，值可能会溢出。C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式（字长为时的）为整数不确定值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此(int) 1e10会得到-2147483648，即从一个正值变为一个负值。\n\n\n2.5 小结\n计算机将信息编码为位（比特），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。\nC语言的设计可以包容多种不同字长和数字编码的实现。64位字长的机器逐渐普及，并正在取代统治市场长达30多年的32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。\n大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码。在位级上理解这些编码，并且理解算术运算的数学特性，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。\n在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个位的值，这种行为是由函数和来描述的。C语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。\n由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于, 从而转换成零时，也会下溢。\n和大多数其他程序语言一样， C语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式x*x 能够得出负数。但是，无符号数和补码的运算都满足整数运算的许多其他属性，包括结合律、交换律和分配律。这就允许编译器做很多的优化。例如，用(x&lt;&lt;3)-x取代表达式7*x时，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以2 的幂之间的关系。\n我们已经看到了几种使用位级运算和算术运算组合的聪明方法。例如，使用补码运算， ~x+1等价于-x。另外一个例子，假设我们想要一个形如的位模式，由个后面紧跟着个组成。这些位模式有助于掩码运算。这种模式能够通过C表达式(1&lt;&lt;k)-1生成，利用的是这样一个属性，即我们想要的位模式的数值为。例如，表达式(1&lt;&lt;8)-1将产生位模式0xFF。\n浮点表示通过将数字编码为的形式来近似地表示实数。最常见的浮点表示方式是由IEEE标准754定义的。它提供了几种不同的精度，最常见的是单精度（32位）和双精度（64位）。IEEE浮点也能够表示特殊值、和 。\n必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算术属性，比如结合性。\n","categories":["CSAPP笔记"]}]