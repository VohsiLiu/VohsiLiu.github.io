[{"title":"0-1分布参数的区间估计","url":"/2022/01/06/0-1%E5%88%86%E5%B8%83%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BC%B0%E8%AE%A1/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/0-1%E5%88%86%E5%B8%83%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BC%B0%E8%AE%A1.pdf\") \n","categories":["概率论与数理统计"]},{"title":"二叉树的遍历","url":"/2022/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","content":"二叉树的遍历二叉树节点的定义struct TreeNode &#123;\t\tint val;\t\tTreeNode *left;\t\tTreeNode *right;\t\tTreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) \t\t&#123;&#125;&#125;;\n\n前序遍历递归实现vector&lt;int&gt; preOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tpreOrder(root,res);\t\treturn res;&#125;    void preOrder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn;\t\t&#125;\t\tres.push_back(root-&gt;val);\t\tpreOrder(root-&gt;left,res);\t\tpreOrder(root-&gt;right,res);&#125;\n\n非递归实现当栈不为空时，栈顶元素出栈，如果其右子节点不为空，则右子节点入栈，其左字节点不为空，则左字节点入栈，这样出栈时，则会先出左子节点，再出右子节点，则能够完成树的前序遍历\nvector&lt;int&gt; preOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tif (root == nullptr)&#123;\t\t\t\treturn res;\t\t&#125;\t\tstack&lt;TreeNode*&gt; s;\t\ts.push(root);\t\twhile (!s.empty())&#123;\t\t\t\tTreeNode* temp = s.top();\t\t\t\ts.pop();\t\t\t\tres.push_back(temp-&gt;val);\t\t\t\tif (temp-&gt;right)&#123;\t\t\t\t\t\ts.push(temp-&gt;right);\t\t\t\t&#125;\t\t\t\tif (temp-&gt;left)&#123;\t\t\t\t\t\ts.push(temp-&gt;left);\t\t\t\t&#125;\t\t&#125;\t\treturn res;&#125;\n\n中序遍历递归实现vector&lt;int&gt; inOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tinOrder(root,res);\t\treturn res;&#125;void inOrder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn;\t\t&#125;\t\tinOrder(root-&gt;left,res);\t\tres.push_back(root-&gt;val);\t\tinOrder(root-&gt;right,res);&#125;\n\n非递归实现vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tif (root == nullptr)&#123;\t\t\t\treturn res;\t\t&#125;\t\tstack&lt;TreeNode*&gt; stk;\t\twhile (!stk.empty() || root != nullptr)&#123;\t\t\t\t//不断往左子树方向走，每走一次就将当前节点保存到栈中\t\t\t\twhile (root != nullptr)&#123;\t\t\t\t\t\tstk.push(root);\t\t\t\t\t\troot = root-&gt;left;\t\t\t\t&#125;\t\t\t\t//当前节点为空，说明左边走到头了，从栈中弹出节点并保存\t\t\t\t//然后转向右边节点，继续上面整个过程\t\t\t\troot = stk.top();\t\t\t\tstk.pop();\t\t\t\tres.push_back(root-&gt;val);\t\t\t\troot = root-&gt;right;\t\t&#125;\t\treturn res;&#125;\n\n后序遍历递归实现vector&lt;int&gt; postOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tpostOrder(root,res);\t\treturn res;&#125;void postOrder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn;\t\t&#125;\t\tpostOrder(root-&gt;left,res);\t\tpostOrder(root-&gt;right,res);\t\tres.push_back(root-&gt;val);&#125;\n\n非递归实现因为后序遍历二叉树的顺序是先访问左子树，再访问右子树，最后访问根节点。当用堆栈来存储节点，必须分清返回根节点时，是从左子树返回的，还从右子树返回的。所以，使用辅助指针prev指向最近访问过的节点，来判断是否从右子树返回。也可以在节点中增加一个标志域，记录是否已被访问。\nvector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tif (root == nullptr)&#123;\t\t\t\treturn res;\t\t&#125;\t\tstack&lt;TreeNode*&gt; stk;\t\tTreeNode* prev = nullptr;\t\twhile (root != nullptr || !stk.empty())&#123;\t\t\t\twhile (root != nullptr)&#123;//不断往左子树方向走\t\t\t\t\t\tstk.push(root);\t\t\t\t\t\troot = root-&gt;left;\t\t\t\t&#125;\t\t\t\troot = stk.top();\t\t\t\tstk.pop();\t\t\t\tif (root-&gt;right &amp;&amp; root-&gt;right != prev)&#123;//右子树存在且未被访问\t\t\t\t\t\tstk.push(root);//从左子树返回，不能弹出根节点，应再压回栈内\t\t\t\t\t\troot = root-&gt;right;\t\t\t\t&#125;else&#123;\t\t\t\t\t\tres.push_back(root-&gt;val);\t\t\t\t\t\tprev = root;\t\t\t\t\t\troot = nullptr;\t\t\t\t&#125;\t\t&#125;\t\treturn res;&#125;\n\n按层次遍历//遍历结果将一个层次存储到一个vector中vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;\t\tvector&lt;vector&lt;int&gt;&gt; result;\t\t//树为空直接返回\t\tif (root == nullptr)&#123;\t\t\t\treturn result;\t\t&#125;\t\tqueue&lt;TreeNode*&gt; q;\t\tq.push(root); //先将根节点入队\t\twhile (!q.empty())&#123;\t\t\t\tvector&lt;int&gt; temp;\t\t\t\tint n = q.size();\t\t\t\tfor (int i = 0; i &lt; n; i++)&#123;\t\t\t\t\t\tTreeNode* node = q.front();\t\t\t\t\t\tq.pop(); //出队并保存节点\t\t\t\t\t\ttemp.push_back(node-&gt;val);\t\t\t\t\t\t//将节点的左子树入队\t\t\t\t\t\tif (node-&gt;left != nullptr)&#123;\t\t\t\t\t\t\t\tq.push(node-&gt;left);\t\t\t\t\t\t&#125;            //将节点的右子树入队\t\t\t\t\t\tif (node-&gt;right != nullptr)&#123;\t\t\t\t\t\t\t\tq.push(node-&gt;right);\t\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tresult.push_back(temp);\t\t&#125;\t\treturn result;&#125;\n\n","categories":["数据结构与算法"]},{"title":"PCA","url":"/2022/01/06/PCA/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/PCA.pdf\") \n","categories":["概率论与数理统计"]},{"title":"TypeScript安装","url":"/2022/07/11/TypeScript%E5%AE%89%E8%A3%85/","content":"TypeScript安装建议采用局部安装，即只安装到项目目录下，不建议全局安装，尤其是在用nvm管理nodejs版本的情况下更不建议了。\nMacOS和Linux所有操作都是在项目目录下进行的\nsudo npm install typescript -D\n\nsudo npm install ts-node -D\n\n如果要直接运行.ts文件的话，输入\nnpx ts-node 文件名.ts \n\n如果要编译为js文件的话，输入\nnpx tsc 文件名.ts  \n\nWindows所有操作都是在项目目录下进行的\n以管理员模式运行cmd，定位到项目目录\nnpm install typescript -D\n\nnpm install ts-node -D\n\n如果要直接运行.ts文件的话，输入\nnpx ts-node 文件名.ts \n\n如果要编译为js文件的话，输入\nnpx tsc 文件名.ts \n\n","categories":["编程环境安装和配置"]},{"title":"二叉搜索树的验证、查找、插入和删除","url":"/2022/06/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/","content":"二叉搜索树的查找、插入和删除二叉搜索树二叉搜索树又被称为二叉排序树，它本身也是一棵二叉树，且满足以下性质：\n\n若左子树不为空，则左子树上左右节点的值都小于根节点的值\n若它的右子树不为空，则它的右子树上所有的节点的值都大于根节点的值\n它的左右子树也要分别是二叉搜索树\n\nstruct TreeNode &#123;\t\tint val;\t\tTreeNode *left;\t\tTreeNode *right;\t\tTreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) \t\t&#123;&#125;&#125;;\n\n验证是否为二叉搜索树递归法利用有效二叉树的定义：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\nbool helper(TreeNode* root, long long lower, long long upper)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn true;\t\t&#125;\t\tif (root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)&#123;\t\t\t\treturn false;\t\t&#125;\t\treturn helper(root-&gt;left, lower, root-&gt;val)       \t\t\t&amp;&amp; helper(root-&gt;right, root-&gt;val, upper);&#125;bool isValidBST(TreeNode* root) &#123;\t\treturn helper(root, LONG_MIN, LONG_MAX);&#125;\n\n中序遍历中序遍历结果应为递增序列\n二叉搜索树的查找TreeNode* searchBST(TreeNode* root, int val) &#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn nullptr;\t\t&#125;\t\tif (root-&gt;val == val)&#123;\t\t\t\treturn root;\t\t&#125;\t\treturn root-&gt;val &gt; val ? searchBST(root-&gt;left, val) : searchBST(root-&gt;right, val);&#125;\n\n二叉搜素树的插入当将 val插入到以 root为根的子树上时，根据 val与 root.val的大小关系，就可以确定要将 val插入到哪个子树中：\n\n如果该子树不为空，则问题转化成了将 val插入到对应子树上\n否则，在此处新建一个以 val为值的节点，并链接到其父节点 root上\n\nTreeNode* insertIntoBST(TreeNode* root, int val) &#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn new TreeNode(val);\t\t&#125;\t\tTreeNode* pos = root;\t\twhile (pos != nullptr)&#123;\t\t\t\tif (pos-&gt;val &lt; val)&#123;\t\t\t\t\t\tif (pos-&gt;right == nullptr)&#123;\t\t\t\t\t\t\t\tpos-&gt;right = new TreeNode(val);\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t&#125; else&#123;\t\t\t\t\t\t\t\tpos = pos-&gt;right;\t\t\t\t\t\t&#125;\t\t\t\t&#125; else&#123;\t\t\t\t\t\tif (pos-&gt;left == nullptr)&#123;\t\t\t\t\t\t\t\tpos-&gt;left = new TreeNode(val);\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t&#125; else&#123;\t\t\t\t\t\t\t\tpos = pos-&gt;left;\t\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t&#125;\t\treturn root;&#125;\n\n二叉搜索树的的删除删除操作比较复杂，可以分为以下三种情况：\n\n被删除节点为叶子节点：直接删除该节点\n被删除结点有一个左孩子或一个右孩子：将孩子结点设为该结点的父结点的孩子后，即可删除该结点\n被删除结点有两个孩子结点：一般的删除策略是，用被删除结点的右子树中的最小结点替代被删除结点，并递归地删除这个最小数据结点\n\n利用前继和后继节点也可以分为以下三种情况：\n\n要删除的节点为叶子节点，可以直接删除\n\n\n\n要删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点\n\n\n\n删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点\n\n\n//寻找后继节点TreeNode* successor(TreeNode* root)&#123;\t\troot = root-&gt;right;\t\twhile (root-&gt;left != nullptr)&#123;\t\t\t\troot = root-&gt;left;\t\t&#125;\t\treturn root;&#125;//寻找前继节点TreeNode* predecessor(TreeNode* root)&#123;\t\troot = root-&gt;left;\t\twhile (root-&gt;right != nullptr)&#123;\t\t\t\troot = root-&gt;right;\t\t&#125;\t\treturn root;&#125;TreeNode* deleteNode(TreeNode* root, int key) &#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn nullptr;\t\t&#125;\t\tif (root-&gt;val &gt; key)&#123; //在左子树中寻找要删除的节点\t\t\t\troot-&gt;left = deleteNode(root-&gt;left, key);\t\t&#125; else if(root-&gt;val &lt; key)&#123; //在右子树中寻找要删除的节点\t\t\t\troot-&gt;right = deleteNode(root-&gt;right, key);\t\t&#125; else&#123; //找到要删除的节点\t\t\t\tif (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;          \t//如果是叶子节点，则直接删除\t\t\t\t\t\troot = nullptr;\t\t\t\t&#125; else if (root-&gt;right != nullptr)&#123;           \t//如果有右子树，则用其后继值代替，并递归的删除这个后继节点\t\t\t\t\t\troot-&gt;val = successor(root)-&gt;val;\t\t\t\t\t\troot-&gt;right = deleteNode(root-&gt;right, root-&gt;val);\t\t\t\t&#125; else&#123;          \t//如果左右子树，则用其后继值代替，并递归的删除这个后继节点\t\t\t\t\t\troot-&gt;val = predecessor(root)-&gt;val;\t\t\t\t\t\troot-&gt;left = deleteNode(root-&gt;left, root-&gt;val);\t\t\t\t&#125;\t\t&#125;\t\treturn root;&#125;//注意：这里的前继节点和后继节点并不是严格意义上的，而是建立在左（右）子树存在的基础上的\n\n","categories":["数据结构与算法"]},{"title":"信号量与PV操作","url":"/2022/12/20/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8EPV%E6%93%8D%E4%BD%9C/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8EPV%E6%93%8D%E4%BD%9C.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995200&Signature=lhopjzeThmiNxY57mRkLA87Jfpk%3D\") ","categories":["操作系统"]},{"title":"商业模式","url":"/2022/12/01/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/requirement/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258361&Signature=PrikJXxF/xrSIng5cRbJ1zZHCCc%3D\") \n\n","categories":["需求与商业模式创新"]},{"title":"商务智能简答题整理","url":"/2022/12/18/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E7%AE%80%E7%AD%94%E9%A2%98%E6%95%B4%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/business%20intelligence/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E7%AE%80%E7%AD%94%E9%A2%98.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707790284&Signature=8fZMcjNQsn78ua1Z5gHopSIosfA%3D\") ","categories":["商务智能"]},{"title":"商务智能选择题整理","url":"/2022/12/18/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/business%20intelligence/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E9%80%89%E6%8B%A9%E9%A2%98.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707790300&Signature=VILOTsdcoeXvwUB8Jmgle64JCy4%3D\") ","categories":["商务智能"]},{"title":"处理器调度算法","url":"/2022/12/20/%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995187&Signature=bkqMeVukXizWo5XIJ/DQ65p4Qbc%3D\") ","categories":["操作系统"]},{"title":"常见函数的级数展开","url":"/2022/01/06/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%BA%A7%E6%95%B0%E5%B1%95%E5%BC%80.pdf\") \n","categories":["概率论与数理统计"]},{"title":"常见概率分布的期望和方差","url":"/2022/01/06/%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%92%8C%E6%96%B9%E5%B7%AE/","content":" location.replace(\"https://vohsiliu.gitee.io/pdfblog/%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%92%8C%E6%96%B9%E5%B7%AE.pdf\") \n\n","categories":["概率论与数理统计"]},{"title":"操作系统课后作业1","url":"/2022/12/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A1/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E4%BD%9C%E4%B8%9A1.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702992997&Signature=ib3SUNwNV75qfHwu57ukNptbi3I%3D\") \n","categories":["操作系统"]},{"title":"操作系统MOOC习题答案","url":"/2022/12/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FMOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FMOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702870212&Signature=NjmQ%2BfSvwUkMxW5XJH8Eid2wj8o%3D\") \n\n","categories":["操作系统"]},{"title":"操作系统课后作业2","url":"/2022/12/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A2/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E4%BD%9C%E4%B8%9A2.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702993066&Signature=9qRnXcxYfBZ4sBsUtl31qUIx0kg%3D\") \n","categories":["操作系统"]},{"title":"操作系统选择题整理","url":"/2022/12/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719825733&Signature=6UZlZ5FF9ToTMwU0Jfr6CHW4hmc%3D\") ","categories":["操作系统"]},{"title":"服务计算与服务生态系统MOOC习题答案","url":"/2023/04/02/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9FMOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/SOA/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9FMOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1711529799&Signature=bvA3SZTQNH6eM3N%2Bj4iJpU1bSrE%3D\") ","categories":["面向服务的软件工程"]},{"title":"数据热力学","url":"/2022/01/06/%E6%95%B0%E6%8D%AE%E7%83%AD%E5%8A%9B%E5%AD%A6/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/%E6%95%B0%E6%8D%AE%E7%83%AD%E5%8A%9B%E5%AD%A6.pdf\") \n","categories":["概率论与数理统计"]},{"title":"期末考试重点","url":"/2022/12/28/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/requirement/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1706155223&Signature=aHiJaQDXUW9Rf6KiRFZ5YccjFT4%3D\") ","categories":["需求与商业模式创新"]},{"title":"概率论与数理统计笔记","url":"/2022/01/06/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/Probability.pdf\") \n\n","categories":["概率论与数理统计"]},{"title":"正态总体均值、方差的检验法","url":"/2022/01/06/%E6%AD%A3%E6%80%81%E6%80%BB%E4%BD%93%E5%9D%87%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%9A%84%E6%A3%80%E9%AA%8C%E6%B3%95/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/%E6%AD%A3%E6%80%81%E6%80%BB%E4%BD%93%E5%9D%87%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%9A%84%E6%A3%80%E9%AA%8C%E6%B3%95.pdf\") \n","categories":["概率论与数理统计"]},{"title":"正态总体均值、方差的置信区间与单侧置信限","url":"/2022/01/06/%E6%AD%A3%E6%80%81%E6%80%BB%E4%BD%93%E5%9D%87%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%9A%84%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E4%B8%8E%E5%8D%95%E4%BE%A7%E7%BD%AE%E4%BF%A1%E9%99%90/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/%E6%AD%A3%E6%80%81%E6%80%BB%E4%BD%93%E5%9D%87%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%9A%84%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E4%B8%8E%E5%8D%95%E4%BE%A7%E7%BD%AE%E4%BF%A1%E9%99%90.pdf\") \n","categories":["概率论与数理统计"]},{"title":"磁盘调度算法","url":"/2022/12/20/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995168&Signature=O2MADOuGaTtyErayj27H2kOuiH0%3D\") ","categories":["操作系统"]},{"title":"第一章 操作系统概论","url":"/2022/07/26/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter1.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258176&Signature=iQq2I0tcLemlhxU3WsuVoycJ2AM%3D\") \n\n","categories":["操作系统"]},{"title":"第一章 概述","url":"/2022/06/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter1.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826785&Signature=1OxBN5xrUUAPI9RZiZkfDzxv8wI%3D\") ","categories":["计算机网络"]},{"title":"第一章 绪论","url":"/2022/06/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/","content":"第一章 绪论1.1 数据库系统概述1.1.1 数据库的4个基本概念1. 数据\n描述事物的符号记录称为数据\n数据的含义称为数据的语义，数据与其语义密不可分\n\n2. 数据库\n数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易拓展性，并可为各种用户共享\n概括来讲，数据库数据具有永久存储、有组织和可共享三个基本特点\n\n3. 数据库管理系统数据库管理系统（DBMS）的主要功能包括以下几个方面：\n\n数据定义功能\n数据组织、存储和管理\n数据操纵功能\n数据库的事务管理和运行管理\n数据库的建立和维护功能\n其他功能\n\n4. 数据库系统数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统\n\n\n1.1.2 数据管理技术的产生和发展\n\n\n\n人工管理阶段\n文件系统阶段\n数据库系统阶段\n\n\n\n应用背景\n科学计算\n科学计算、数据管理\n大规模数据管理\n\n\n硬件背景\n无直接存取存储设备\n磁盘、磁鼓\n大容量磁盘、磁盘阵列\n\n\n软件背景\n没有操作系统\n有文件系统\n有数据库管理系统\n\n\n处理方式\n批处理\n联机实时处理、批处理\n联机实时处理、分布处理、批处理\n\n\n数据的管理者\n用户（程序员）\n文件系统\n数据库管理系统\n\n\n数据面向的对象\n某一应用程序\n某一应用\n现实世界\n\n\n数据的共享程度\n无共享、冗余度极大\n共享性差、冗余度大\n共享性高、冗余度小\n\n\n数据的独立性\n不独立、完全依赖于程序\n独立性差\n具有高度的物理独立性和一定的逻辑独立性\n\n\n数据的结构化\n无结构\n记录内有结构、整体无结构\n整体结构化，用数据模型描述\n\n\n数据控制能力\n应用程序自己控制\n应用程序自己控制\n由数据库管理系统提供数据安全性、完整性、并发控制和恢复能力\n\n\n数据库系统的特点：\n\n数据结构化\n\n整体结构化\n不再仅仅针对某一个应用，而是面向全组织\n不仅数据内部结构化，整体是结构化的，数据之间具有联系\n数据记录可以变长\n数据的最小存取单位是数据项\n\n\n数据的用数据模型描述，无需应用程序定义\n\n\n数据的共享性高，冗余度低且易扩充\n\n数据面向整个系统，可以被多个用户、多个应用共享使用\n数据共享的好处\n减少数据冗余，节约存储空间\n避免数据之间的不相容性与不一致性 \n使系统易于扩充\n\n\n\n\n数据独立性高\n\n物理独立性\n指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不用改变\n\n\n逻辑独立性\n指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变\n\n\n数据独立性由数据库管理系统的二级映像功能来保证\n\n\n数据由数据管理系统统一管理和控制\n\n数据库管理系统提供的数据控制功能\n数据的安全性保护：保护数据以防止不合法的使用造成的数据的泄密和破坏\n数据的完整性检查：保证数据的正确性、有效性和相容性\n并发控制：对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果\n数据库恢复：将数据库从错误状态恢复到某一已知的正确状态\n\n\n\n\n\n1.2 数据模型1.3 数据库系统的结构1.3.1 数据库系统模式的概念\n在数据库模型中有“型“和”值“的概念\n型是指对某一类数据的结构和属性的说明\n值是型的一个具体赋值\n\n\n模式是数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，不涉及具体值\n模式的一个具体的值称为模式的实例，同一个模式可以有多个实例\n\n1.3.2 数据库的三级模式结构\n\n1. 模式\n模式，也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图\n一个数据库只有一个模式\n模式是数据库系统模式结构的中间层，与数据的物理存储细节和硬件环境无关，与具体的应用程序、开发工具及高级程序设计语言无关\n定义模式时不仅要定义数据的逻辑结构，而且要定义数据之间的联系，定义数据有关的安全性、完整性要求\n\n2. 外模式\n外模式也称子模式或用户模式，它是数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示\n\n模式与外模式的关系：一对多\n\n外模式通常是模式的子集\n一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求\n对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同\n\n\n外模式与应用的关系：一对多\n\n同一外模式也可以为某一用户的多个应用系统所使用\n但一个应用程序只能使用一个外模式\n\n\n外模式的用途\n\n保证数据库安全性的一个有力措施\n每个用户只能看见和访问所对应的外模式中的数据\n\n\n\n3. 内模式\n内模式也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式\n\n记录的存储方式（例如，顺序存储，堆存储，hash存储等）\n索引的组织方式\n数据是否压缩存储\n数据是否加密\n数据存储记录结构的规定\n\n\n一个数据库只有一个内模式\n\n\n1.3.3 数据库的二级映像功能与数据独立性\n数据库系统的三级模式是数据的三个抽象级别，它把数据的具体组织留给数据库管理系统，使用户能逻辑地、抽象地处理数据，而不必关心数据在计算机中的具体表示方式与存储方式\n为了能够在系统内部实现这三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像\n\n1. 外模式/模式映像\n模式描述的是数据的全局逻辑结构\n外模式：描述的是数据的局部逻辑结构 \n同一个模式可以有任意多个外模式 \n每一个外模式，数据库系统都有一个外模式/模式映象，定义外模式与模式之间的对应关系\n映象定义通常包含在各自外模式的描述中\n保证数据的逻辑独立性\n当模式改变时，数据库管理员对外模式/模式映象作相应改变，使外模式保持不变\n应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性\n\n\n\n2. 模式/内模式映像\n模式/内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。\n数据库中模式/内模式映象是唯一的\n该映象定义通常包含在模式描述中\n保证数据的物理独立性\n当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式/内模式映象，使模式保持不变\n应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性\n\n\n\n3. 数据库的二级映像\n数据库模式\n\n即全局逻辑结构是数据库的中心与关键\n独立于数据库的其他层次 \n设计数据库模式结构时应首先确定数据库的逻辑模式\n\n\n数据库的内模式\n\n依赖于它的全局逻辑结构\n独立于数据库的用户视图，即外模式\n独立于具体的存储设备 \n将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率\n\n\n数据库的外模式\n\n面向具体的应用程序\n定义在逻辑模式之上\n独立于存储模式和存储设备\n当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动\n设计外模式时应充分考虑到应用的扩充性\n\n\n特定的应用程序\n\n在外模式描述的数据结构上编制的\n依赖于特定的外模式\n与数据库的模式和存储结构独立\n不同的应用程序有时可以共用同一个外模式\n\n\n数据库的二级映像\n\n保证了数据库外模式的稳定性\n从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改\n\n\n数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去\n\n数据的存取由数据库管理系统管理\n\n简化了应用程序的编制\n大大减少了应用程序的维护和修改\n\n\n\n1.4 数据库系统的组成1. 硬件平台及数据库数据库系统对硬件资源的要求\n\n足够大的内存\n\n足够的大的磁盘或磁盘阵列等设备\n\n较高的通道能力，提高数据传送率\n\n\n2. 软件数据库系统的软件主要包括\n\n数据库管理系统\n支持数据库管理系统运行的操作系统\n与数据库接口的高级语言及其编译系统\n以数据库管理系统为核心的应用开发工具\n为特定应用环境开发的数据库应用系统\n\n3. 人员\n\n（1）数据库管理人员\n\n决定数据库中的信息内容和结构\n\n决定数据库的存储结构和存取策略\n\n定义数据的安全性要求和完整性约束条件\n\n监控数据库的使用和运行\n\n周期性转储数据库\n数据文件\n日志文件\n系统故障恢复\n介质故障恢复\n监视审计文件\n\n\n\n\n数据库的改进和重组\n\n性能监控和调优\n定期对数据库进行重组织，以提高系统的性能 \n需求增加和改变时，数据库须需要重构造\n\n\n\n（2）系统分析员\n\n负责应用系统的需求分析和规范说明\n与用户及数据库管理员结合，确定系统的硬软件配置\n参与数据库系统的概要设计\n\n（3）数据库设计人员\n\n参加用户需求调查和系统分析\n确定数据库中的数据\n设计数据库各级模式\n\n（4）应用程序员\n\n设计和编写应用系统的程序模块\n进行调试和安装\n\n（5）最终用户：最终用户通过应用系统的用户接口使用数据库。\n\n偶然用户\n\n不经常访问数据库，但每次访问数据库时往往需要不同的数据库信息 \n企业或组织机构的高中级管理人员\n\n\n简单用户\n\n主要工作是查询和更新数据库 \n\n银行的职员、机票预定人员、旅馆总台服务员\n\n\n\n复杂用户\n\n工程师、科学家、经济学家、科技工作者等\n直接使用数据库语言访问数据库，甚至能够基于数据库管理系统的应用程序接口编制自己的应用程序\n\n\n\n","categories":["数据库"]},{"title":"第七章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第三章 存储管理","url":"/2022/08/13/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter3.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258245&Signature=D7s0GAQ1YjosQ7iAn6lmCnghs9o%3D\") \n\n","categories":["操作系统"]},{"title":"第三章 数据链路层","url":"/2022/06/06/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter3.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826857&Signature=4p77pi9HqI5FynjGdJzQTi7uKe0%3D\") ","categories":["计算机网络"]},{"title":"第一章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第九章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第九章 无线网络和移动网络","url":"/2022/06/06/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/","content":"第九章 无线网络和移动网络9.1 无线局域网WLAN9.1.1 无线局域网的组成无线局域网可分为有固定基础设施的和无固定基础设施的两大类。“固定基础设施”是指预先建立起来的、能够覆盖一定地理范围的一批固定基站\n1. IEEE 802.11\n对于第一类有固定基础设施的无线局域网，1997 年 IEEE 制定出无线局域网的协议标准 802.11[W-IEEE802.11]系列标准\n802.11 是无线以太网的标准，它使用星形拓扑，其中心叫做接入点 AP（Access Point），在 MAC 层使用 CSMA/CA 协议\n凡使用 802.11 系列协议的局域网又称为 Wi-Fi（Wireless-Fidelity，意思是“无线保真度”）\n现在 Wi-Fi 实际上已经成为了无线局域网 WLAN 的代名词，但无线局域网和“保真度”实在没有什么关系\n802.11 标准规定无线局域网的最小构件是基本服务集 BSS（Basic Service Set）\n一个基本服务集 BSS 包括一个基站和若干个移动站，一个站无论要和本 BSS 的站进行通信，还是要和其他 BSS 的站进行通信，都必须通过本 BSS 的基站\n\n\n\n9.1.2 802.11 局域网的物理层9.1.3 802.11 局域网的MAC层1. CSMA/CA 协议\n在无线局域网中，仍然可以使用载波监听多址接入 CSMA , 即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞\n在无线局域网中，不能使用碰撞检测CD ，原因如下：\n由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD ，对硬件的要求非常高\n即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题）， 进行碰撞检测的意义也不大\n\n\n\n\n\n802.11 无线局域网使用 CSMA/CA 协议，在 CSMA 的基础上增加了一个碰撞避免 CA 功能，而不再实现碰撞检测功能\n\n由于不可能避免所有的碰撞，并且无线信道误码率较高， 802.11 标准还使用了数据链路层确认机制（停止-等待协议） 来保证数据被正确接收\n\n802.11 的 MAC 层标准定义了两种不同的媒体接入控制方式：\n\n分布式协调功能 DCF（Distributed Coordination Function）。在 DCF 方式下，没有中心控制站点，每个站点使用 CSMA/CA 协议通过争用信道来获取发送权，这是802.11 定义的默认方式\n\n点协调功能 PCF（Point Coordination Function）。PCF 方式使用集中控制的接入算法（一般在接入点AP 实现集中控制），是802.11 定义的可选方式，在实际中较少使用\n\n\n\n802.11 标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔IFS（InterFrame Space）\n\n帧间间隔的长短取决于该站点要发送的帧的类型：\n\n高优先级帧需要等待的时间较短，因此可优先获得发送权；\n优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。\n\n\n常用的两种帧间间隔如下：\n\n短帧间间隔 SIFS（），是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用 SIFS 的帧类型有 ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧、以及所有回答 AP 探询的帧和在 PCF 方式中接入点 AP 发送出的任何帧\nDCF 帧间间隔 DIFS（），它比短帧间间隔 SIFS 要长得多，在 DCF 方式中用来发送数据帧和管理帧\n\n\n\nCSMA/CA 协议工作原理：\n\n\n当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法\n以下情况必须使用退避算法：\n在发送数据帧之前检测到信道处于忙状态时\n每一次重传一个数据帧时\n在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）\n\n\n在执行退避算法时，站点为退避计时器设置一个随机的退避时间：\n当退避计时器的时间减小到零时，就开始发送数据\n当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间 DIFS 后，继续启动退避计时器\n\n\n在进行第次退避时，退避时间在时隙编号中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少.当时隙编号达到255时（对应于第6次退避）就不再增加了\n\n\n2. 对信道进行预约\n为了尽可能减少碰撞的概率和降低碰撞的影响， 802.11 标准允许要发送数据的站点对信道进行预约\n源站在发送数据帧之前先发送一个短的控制帧，称为请求发送 RTS（request to send），它包括源地址目的地址以及这次通信（包括相应的确认帧）所需的持续时间\n\n若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送 CTS（clear to send），它也包括这次通信所需的持续时间（从 RTS 帧中将此持续时间复制到 CTS 帧中）\n\n源站收到 CTS 帧后，再等待一段时间 SIFS 后，就可发送其数据帧\n\n若目的站正确收到了源站发来的数据帧，在等待时间 SIFS 后，就向源站发送确认帧 ACK\n\n\n\n\n\n\n\n除源站和目的站以外的其他各站，在收到 CTS 帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰\n\n如果 RTS 帧发生碰撞，源站就收不到 CTS 帧，需执行退避算法重传 RTS 帧\n\n由于RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。802.11 标准规定了3种情况供用户选择：\n\n使用 RTS 帧和 CTS 帧\n不使用 RTS 帧和 CTS 帧\n只有当数据帧的长度超过某一数值时才使用 RTS 帧和 CTS 帧\n\n\n除 RTS 帧和 CTS 帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的虚拟载波监听机制\n\n由于利用虚拟载波监听机制， 站点只要监听到 RTS 帧、CTS 帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题\n\n\nCSMA/CA的基本流程图：\n\n\n\n\n9.1.4 802.11 局域网的MAC帧","categories":["计算机网络"]},{"title":"第二章 处理器管理","url":"/2022/08/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter2.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258226&Signature=/zGkKDmAUdHaZZDvivrmsPw3n90%3D\") \n\n","categories":["操作系统"]},{"title":"第二章 关系数据库","url":"/2022/06/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"第二章 关系数据库2.1 关系数据结构及形式化定义2.1.1 关系\n域：域是一组具有相同数据类型的值的集合\n\n笛卡尔积：给定一组域 ，允许其中某些域是相同的，​的笛卡尔积为\n\n其中，每一个元素叫作一个  元组，或简称元组\n元素中的每一个值  叫做一个分量\n一个域允许的不同取值个数称为这个域的基数\n若  为有限集，其基数为  ，则的基数 \n\n\n关系： 的子集叫做在域名 上的关系，表示为 \n\n 表示关系的名字\n 是关系的目或者度\n\n\n若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码\n\n若一个关系有多个候选码，则选定其中一个为主码\n候选码的诸属性称为主属性\n不包含在任何侯选码中的属性称为非主属性或非码属性\n在简单的情况下，候选码只包含一个属性；在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码\n\n\n关系可以有三种类型：基本关系（基本表或基表）、查询表和视图表\n\n基本关系是实际存在的表，是实际存储数据的逻辑表示\n查询表是查询结果对应的表\n视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据\n\n\n基本关系的性质：\n\n列是同质的，即每一列中的分量是同一类型的数据，来自同一个域\n不同的列可出自同一个域，称其中的每一列称为一个属性，不同的属性要给予不同的属性名\n列的顺序无所谓\n任意两个元组的候选码不能相同\n行的顺序无所谓\n分量必须取原子值\n\n\n\n2.1.2 关系模式\n关系模式是对关系的描述，关系模式是型，关系是值\n\n关系的描述称为关系模式。可以形式化地表示为 \n\n 为关系名\n\n 为组成该关系的属性名集合\n\n 为  中属性所来自的域\n\n 为属性向域的映像集合\n\n 为属性间数据的依赖关系集合\n\n\n\n\n2.1.3 关系数据库\n在一个给定的应用领域中，所有关系的集合构成一个关系数据库\n关系数据库的型，也称关系数据库模式，是对关系数据库的描述\n关系数据库的值，是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库\n\n2.2 关系的完整性\n实体完整性和参照完整性\n\n关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持\n\n\n用户定义的完整性\n\n应用领域需要遵循的约束条件，体现了具体领域中的语义约束\n\n\n2.2.1 实体完整性\n实体完整性规则：若属性  是基本关系  的主属性，则属性  不能取空值。空值就是“不知道”或“不存在”或“无意义”的值\n对于实体完整性规则的说明：\n实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集\n现实世界中的实体是可区分的，即它们具有某种唯一性标识\n关系模型中以主码作为唯一性标识\n主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性\n\n\n\n2.2.2. 参照完整性\n在关系模型中实体及实体间的联系都是用关系来描述的，自然存在着关系与关系间的引用\n设  是基本关系  的一个或一组属性，但不是关系  的码， 是基本关系  的主码。如果  与  相对应，则称  是  的外码，并称基本关系  为参照关系，基本关系  为被参照关系或目标关系\n其中关系  和  不一定是不同的关系\n目标关系  的主码  和参照关系的外码  必须定义在同一个（或一组）域上\n外码并不一定要与相应的主码同名\n当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别\n\n\n\n\n\n\n\n\n参照完整性规则：若属性（或属性组） 是基本关系  的外码它与基本关系  的主码  相对应（基本关系  和  不一定是不同的关系），则对于  中每个元组在  上的值必须为：\n\n或者取空值（ 的每个属性值均为空值）\n\n或者等于  中某个元组的主码值\n\n\n\n\n2.2.3 用户定义的完整性\n用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求\n关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能\n\n2.3 关系代数2.3.1 传统的集合运算\n并：\n差：\n交：\n笛卡尔积：\n\n2.3.2 专门的关系运算首先引入几个记号：\n\n，，：\n\n设关系模式为 \n它的一个关系设为 \n表示  是  的一个元组\n 则表示元组  中相应于属性 的一个分量\n\n\n，， \n\n若，其中  是 中的一部分，则  称为属性列或属性组\n\n表示元组  在属性列 上诸分量的集合\n\n 则表示  中去掉  后剩余的属性组\n\n\n\n：\n\n 为  目关系， 为  目关系\n 称为元组的连接\n 是一个  列的元组，前  个分量为  中的一个  元组，后  个分量为  中的一个  元组\n\n\n象集\n\n给定一个关系 ， 和  为属性组\n当 时， 在  中的象集为：\n它表示  中属性组  上值为  的诸元组在  上分量的集合\n\n\n\n下例中的学生-课程数据库如下：\n\n1. 选择\n选择又称为限制\n\n选择是在关系  中选择满足给定条件的诸元组，记作真其中  表示选择条件，它是一个逻辑表达式，取逻辑值“真”或“假”\n\n逻辑表达式  的基本形式为 θ，其中 θ 表示比较运算符。在基本的选择条件上可以进一步进行逻辑运算\n\n\n选择运算是从行角度进行的运算\n\n\n\n例：查询信息系（IS系）全体学生：，结果如下：\n\n\n\n\nSno\nSame\nSex\nSage\nSlept\n\n\n\n201215125\n张立\n男\n19\nIS\n\n\n2. 投影\n投影是从  中选择出若干属性列组成新的关系，记作\n\n投影操作主要是从列的角度进行运算\n\n投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）\n\n\n\n例：查询学生关系  中都有哪些系，即查询关系  上所在系属性上的投影：，结果如下：\n\n\n\n\nSdept\n\n\n\nCS\n\n\nIS\n\n\nMA\n\n\n3. 连接\n连接也称为 θ 连接，是从两个关系的笛卡尔积中选取属性间满足一定条件的元组，记作θ\n\n连接运算从  和  的广义笛卡尔积  中选取  关系在  属性组上的值与  关系在  属性组上的值满足比较关系 θ 的元组\n\n连接运算中最为重要且最为常用的连接为等值连接和自然连接\n\nθ 为 “” 的连接运算称为等值连接\n\n是从关系  与  的广义笛卡尔积中选取 ​ 属性值相等的那些元组，即等值连接为：\n\n\n\n自然连接是一种特殊的等值连接\n\n要求两个关系中进行比较的分量必须是相同的属性组\n\n并且在结果中把重复的属性列去掉\n\n若  和  具有相同的属性组 ， 为  和 ​ 的全体属性集合，则自然连接可记作\n\n\n\n一般的连接操作是从行的角度进行运算\n\n自然连接还需要取消重复列，所以是同时从行和列的角度进行运算。\n\n\n\n\n\n例：设下图  和  分别为关系  和关系 ，图  为非等值连接  的结果，图  为等值连接 的结果，图  为自然连接  的结果\n\n\n\n两个关系  和  在做自然连接时，关系  中某些元组有可能在  中不存在公共属性上值相等的元组，从而造成  中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组\n如果把悬浮元组也保存在结果关系中，而在其他属性上填空值（Null），就叫做外连接，记作 ⟗\n如果只保留左边关系  中的悬浮元组，则称为左外连接，记作 ⟕\n如果只保留右边关系  中的悬浮元组，则称为右外连接，记作 ⟖\n\n\n\n\n例：下图  是上例中关系  和关系  的外连接，图  是左外连接，图  是右外连接\n\n\n4. 除运算设关系  除以关系  的结果为关系 ，则  包含所有在  但不在  中的属性及其值，且  的元组与  的元组的所有组合都在  中\n用象集定义除运算：\n\n给定关系  和 ，其中  为属性组\n\n 中的  与  中的  可以有不同的属性名，但必须出自相同的域集\n\n 与  的除运算得到一个新的关系 ， 是  中满足下列条件的元组在  属性列上的投影：元组在  上分量值  的象集  包含  在  上投影的集合，记作：其中  为  在  中的象集，\n\n除是同时从行和列的角度进行运算\n\n\n\n例：设关系  分别为下图中的  和  ， 的结果如图 \n\n\n","categories":["数据库"]},{"title":"第二章 物理层","url":"/2022/06/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter2.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826799&Signature=RnEvLUDCMC7sltFgAzbW5C4Yjd8%3D\") \n","categories":["计算机网络"]},{"title":"第五章 数据库完整性","url":"/2022/06/06/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/","content":"第五章 数据库完整性\n数据库的完整性是指数据的正确性和相容性\n数据的正确性是指数据是符合现实世界语义，反映了当前实际状况的\n数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的\n\n\n数据的完整性和安全性是两个既有联系又不尽相同的概念\n数据的完整性\n防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据\n防范对象：不合语义的、不正确的数据\n\n\n数据的安全性\n保护数据库，防止恶意的破坏和非法的存取\n防范对象：非法用户和非法操作\n\n\n\n\n为维护数据库的完整性，数据库管理系统必须实现如下功能\n提供定义完整性约束条件的机制\n完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件\nSQL 标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性\n这些完整性一般由 SQL 的数据定义语言语句来实现\n\n\n提供完整性检查的方法\n数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。\n一般在 INSERT、UPDATE、DELETE 语句执行后开始检查，也可以在事务提交时检查\n\n\n进行违约处理\n数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作，如拒绝（NO ACTION）执行该操作或级连（CASCADE）执行其他操作\n\n\n\n\n\n5.1 实体完整性5.1.1 定义实体完整性关系模型的实体完整性在 CREATE TABLE 中用 PRIMARY KEY 定义。单属性构成的码有两种说明方法，一种是定义为列级约束条件，另一种是定义为表级约束条件；对多个属性构成的码只有一种说明方法，即定义为表级约束条件 \n\n例：将SC表中的Sno，Cno属性组定义为码\n\nCREATE TABLE SC\t\t(Sno CHAR(9) NOT NULL, \t\t Cno CHAR(4) NOT NULL,  \t\t Grade SMALLINT,\t\t PRIMARY KEY (Sno,Cno)\t\t); \n\n5.1.2 实体完整性检查和违约处理插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：\n\n检查主码值是否唯一，如果不唯一则拒绝插入或修改\n检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改\n\n5.2 参照完整性5.2.1 定义参照完整性关系模型的参照完整性在 CREATE TABLE 中用 FOREIGN KEY 短语定义哪些列为外码，用 REFERENCES 短语指明这些外码参照哪些表的主码\n\n例：关系SC中一个元组表示一个学生选修的某门课程的成绩，（Sno，Cno）是主码。Sno、Cno分别参照引用Student表的主码和Course表的主码。定义SC中的参照完整性\n\nCREATE TABLE SC\t\t(Sno CHAR(9) NOT NULL, \t\t Cno CHAR(4) NOT NULL,  \t\t Grade SMALLINT,\t\t PRIMARY KEY (Sno, Cno),  \t\t FOREIGN KEY (Sno) REFERENCES Student(Sno),  \t\t FOREIGN KEY (Cno) REFERENCES Course(Cno)    \t\t);\n\n5.2.2 参照完整性检查和违约处理可能破坏参照完整性的情况及违约处理\n\n\n\n例：显式说明参照完整性的违约处理示例\n\nCREATE TABLE SC(Sno CHAR(9) NOT NULL，Cno CHAR(4) NOT NULL，Grade SMALLINT,PRIMARY KEY(Sno,Cno)， \t\t\tFOREIGN KEY (Sno) REFERENCES Student(Sno) /*在表级定义参照完整性*/\t\t\tON DELETE CASCADE       /*当删除Student表中的元组时，级联删除SC表中相应的元组*/\t\t\tON UPDATE CASCADE,      /*当更新Student表中的sno时，级联更新SC表中相应的元组*/FOREIGN KEY (Cno) REFERENCES Course(Cno)\t/*在表级定义参照完整性*/                    \t\t\tON DELETE NO ACTION /*当删除Course表中的元组造成了与SC表不一致时，拒绝删除*/\t\t\tON UPDATE CASCADE   /*当更新Course表中的cno时，级联更新SC表中相应的元组*/);\n\n5.3 用户定义的完整性5.3.1 属性上的约束条件1. 属性上约束条件的定义在 CREATE TABLE 中定义属性的同时，可以根据应用要求定义属性上的约束条件，即属性值限制，包括\n\n列值非空（NOT NULL）\n列值唯一（UNIQUE）\n检查列值是否满足一个条件表达式（CHECK 短语）\n\n\n例：Student表的Ssex只允许取“男”或“女”\n\nCREATE TABLE Student\t\t(Sno CHAR(9) PRIMARY KEY,\t\t Sname CHAR(8) NOT NULL,                     \t\t Ssex CHAR(2) CHECK (Ssex IN ('男','女'))，           \t\t Sage SMALLINT,\t\t Sdept CHAR(20));\n\n2. 属性上约束条件的检查和违规处理当往表中插入元组或修改属性的值时，关系数据库管理系统将检查属性上的约束条件是否被满足，如果不满足则操作被拒绝执行\n5.3.2 元组上的约束条件1. 元组上约束条件的定义元组级的限制可以设置不同属性之间的取值的相互约束条件\n\n例：当学生的性别是男时，其名字不能以Ms.打头\n\nCREATE TABLE Student\t\t(Sno CHAR(9), \t\t Sname CHAR(8) NOT NULL，\t\t Ssex CHAR(2),\t\t Sage SMALLINT,\t\t Sdept CHAR(20),\t\t PRIMARY KEY (Sno),\t\t CHECK (Ssex = '女' OR Sname NOT LIKE 'Ms.%'));\n\n2. 元组上约束条件的检查和违约处理当往表中插入元组或修改属性的值时，关系数据库管理系统将检查元组上的约束条件是否被满足，如果不满足则操作被拒绝执行\n5.4 完整性约束命名子句1. 完整性约束命名子句CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;\n\n&lt;完整性约束条件&gt;包括 NOT NULL、UNIQUE、PRIMARY KEY 短语、FOREIGN KEY 短语、CHECK 短语等\n2. 修改表中的完整性限制使用 ALTER TABLE 语句修改表中的完整性限制\n\n例：修改表Student中的约束条件，要求学号改为在900000~999999之间，年龄由小于30改为小于40\n\n/*可以先删除原来的约束条件，再增加新的约束条件*/ALTER TABLE Student\t\tDROP CONSTRAINT C1;ALTER TABLE Student\t\tADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999),ALTER TABLE Student\t\tDROP CONSTRAINT C3;ALTER TABLE Student\t\tADD CONSTRAINT C3 CHECK(Sage &lt; 40);\n\n5.5 断言\nSQL 中，可以使用 CREATE ASSERTION 语句，通过声明性断言来指定更具一般性的约束\n\n可以定义涉及多个表的或聚集操作的比较复杂的完整性约束\n\n断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行\n\n\n1. 创建断言的语句格式CREATE ASSERTION &lt;断言名&gt; &lt;CHECK 子句&gt;\n\n每个断言都被赋予一个名字，&lt;CHECK 子句&gt;中的约束条件与 WHERE 子句的条件表达式类似\n\n例：限制数据库课程最多60名学生选修\n\nCREATE ASSERTION ASSE_SC_DB_NUM\t\tCHECK (60 &gt;= (SELECT COUNT(*)\t\t\t\tFROM Course,SC\t\t\t\tWHERE SC.Cno = Course.Cno AND Course.Cname = '数据库')\t\t);\n\n2. 删除断言的语句格式DROP ASSERTION &lt;断言名&gt;;\n\n5.6 触发器\n触发器是用户定义在关系表上的一类由事件驱动的特殊过程\n\n触发器保存在数据库服务器中\n任何用户对表的增、删、改操作均由服务器自动激活相应的触发器\n触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力\n\n\n不同的关系数据库管理系统触发器语法各不相同\n\n\n5.6.1 定义触发器CREATE TRIGGER &lt;触发器名&gt;  {BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt;REFERENCING NEW | OLD ROW AS&lt;变量&gt;FOR EACH  {ROW | STATEMENT}[WHEN &lt;触发条件&gt;]&lt;触发动作体&gt;\n\n\n触发器又叫做事件—条件—动作规则\n\n当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段 SQL 存储过程\n\n\n表的拥有者才可以在表上创建触发器\n\n触发器名\n\n触发器名可以包含模式名，也可以不包含模式名\n\n同一模式下，触发器名必须是唯一的\n\n触发器名和表名必须在同一模式下\n\n\n\n表名\n\n触发器只能定义在基本表上，不能定义在视图上\n当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器\n\n\n触发事件\n\n触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合\n\n\n还可以UPDATE OF&lt;触发列，...&gt;，即进一步指明修改哪些列时激活触发器\n\nAFTER/BEFORE 是触发的时机\nAFTER 表示在触发事件的操作执行之后激活触发器\nBEFORE 表示在触发事件的操作执行之前激活触发器\n\n\n\n\n触发器类型\n\n行级触发器（FOR EACH ROW）\n语句级触发器（FOR EACH STATEMENT）\n\n\n触发条件\n\n触发器被激活时，只有当触发条件为真时触发动作体才执行;否则触发动作体不执行。\n如果省略 WHEN 触发条件，则触发动作体在触发器激活后立即执行\n\n\n触发动作体\n\n触发动作体可以是一个匿名 PL/SQL 过程块\n\n也可以是对已创建存储过程的调用\n\n\n如果是行级触发器，用户都可以在过程体中使用 NEW 和 OLD 引用事件之后的新值和事件之前的旧值\n\n如果是语句级触发器，则不能在触发动作体中使用 NEW 或 OLD 进行引用\n\n\n如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化\n\n\n\n例：当对表SC的Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：SC_U（Sno,Cno,Oldgrade,Newgrade）其中Oldgrade是修改前的分数，Newgrade是修改后的分数\n\nCREATE TRIGGER  SC_T\t\t     /*SC_T是触发器的名字*/AFTER UPDATE OF Grade ON SC  /*UPDATE OF Grade ON SC是触发事件*/\t\t\t\t\t\t\t\t\t\t\t\t\t\t /*AFTER是触发时机，表示当对SC的Grade属性修改完后再触发下面的规则*/REFERENCING\t\tOLD row  AS  OldTuple,\t\tNEW row AS  NewTupleFOR EACH ROW \t\t\t\t\t\t\t\t /*行级触发器，即每执行一次Grade的更新，下面的规则就执行一次*/WHEN (NewTuple.Grade &gt;= 1.1*OldTuple.Grade)      /*触发条件，只有该条件为真时才执行*/\t\tINSERT INTO SC_U(Sno,Cno,OldGrade,NewGrade)  /*下面的INSERT操作*/\t\tVALUES(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade)\n\n5.6.2 激活触发器\n触发器的执行，是由触发事件激活的，并由数据库服务器自动执行\n一个数据表上可能定义了多个触发器，遵循如下的执行顺序:\n执行该表上的 BEFORE 触发器\n激活触发器的 SQL 语句\n执行该表上的 AFTER 触发器\n\n\n\n5.6.3 删除触发器DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;\n\n","categories":["数据库"]},{"title":"第五章 运输层","url":"/2022/06/06/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter5.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826906&Signature=LhvetstPJinYML5qonWz%2BBpH4Ks%3D\") ","categories":["计算机网络"]},{"title":"第六章 关系数据理论","url":"/2022/06/06/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/","content":"第六章 关系数据理论6.1 关系模式及范式\n关系模式由五部分组成，是一个五元组：\n\n\n关系名  是符号化的元组语义\n 为一组属性\n 为属性组  中的属性所来自的域\n 为属性到域的映射\n 为属性组  上的一组数据依赖\n\n\n由于 、 与模式设计关系不大，因此可以把关系模式看作一个三元组：\n\n当且仅当  上的一个关系  满足  时， 称为关系模式  的一个关系\n作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于第一范式（1NF）\n\n\n数据依赖\n\n是一个关系内部属性与属性之间的一种约束关系\n\n通过属性间值的相等与否体现出来的数据间相关联系\n\n\n\n\n是现实世界属性间相互联系的抽象\n\n是数据内在的性质\n\n\n是语义的体现\n\n数据依赖的主要类型\n\n函数依赖（Functional Dependency，简记为 FD）\n多值依赖（Multi-Valued Dependency，简记为 MVD）\n\n\n第一范式的问题有\n\n数据冗余\n更新异常\n插入异常\n删除异常\n\n\n\n6.2 规范化6.2.1 函数依赖设  是一个属性集  上的关系模式， 和  是  的子集。若对于  的任意一个可能的关系 ， 中不可能存在两个元组在  上的属性值相等，而在  上的属性值不等， 则称“ 函数确定 “或“ 函数依赖于 ”，记作 ， 称为这个函数依赖的决定因素\n\n函数依赖不是指关系模式  的某个或某些关系实例满足的约束条件，而是指  的所有关系实例均要满足的约束条件\n\n函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖\n\n数据库设计者可以对现实世界作强制的规定\n\n\n在关系模式  中，对于  的子集  和 ，\n\n，但 ，则称  是非平凡的函数依赖\n\n，但 ，则称  是平凡的函数依赖\n\n对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。因此若不特别声明，我们总是讨论非平凡函数依赖。\n\n\n在  中，如果 ，并且对于  的任何一个真子集 ，都有 , 则称  对  完全函数依赖，记作 \n\n若 ，但  不完全函数依赖于 ，则称  对  部分函数依赖，记作 \n\n在  中，如果 ，，，, 则称  对  传递函数依赖，记为：传递\n\n如果 , 即 ，则  直接依赖于 ，而不是传递函数依赖\n\n6.2.2 码设  为  中的属性或属性组合。若 ，则  称为  的一个候选码\n\n如果  部分函数依赖于 ，即 ，则  称为超码\n\n候选码的超集是超码，候选码的真子集一定不是超码\n\n\n若关系模式  有多个候选码，则选定其中的一个做为主码\n\n主属性与非主属性\n\n包含在任何一个候选码中的属性 ，称为主属性\n不包含在任何码中的属性称为非主属性或非码属性\n\n\n全码：整个属性组是码，称为全码\n\n\n关系模式  中属性或属性组  并非  的码，但  是另一个关系模式的码，则称  是  的外部码也称外码\n主码与外部码一起提供了表示关系间联系的手段\n6.2.3 范式\n范式是符合某一种级别的关系模式的集合\n关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式\n一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化\n\n\n\n6.2.4 2NF若关系模式 ，并且每一个非主属性都完全函数依赖于任何一个候选码，则 \n6.2.5 3NF设关系模式 ，若  中不存在这样的码 、属性组  及非主属性 ，使得 ， 成立， 不成立，则称 \n6.2.6 BCNF\nBCNF 由 Boyce 和 Codd 提出，比 3NF更进了一步。通常认为 BCNF 是修正的第三范式，有时也称为扩充的第三范式\n\n设关系模式 ，若  且 时  必含有码，则 \n\n换言之，在关系模式  中，如果每一个决定属性集都包含候选码，则 \n\nBCNF 的关系模式所具有的性质\n\n所有非主属性都完全函数依赖于每个候选码\n所有主属性都完全函数依赖于每个不包含它的候选码\n没有任何属性完全函数依赖于非码的任何一组属性\n\n\n如果一个关系数据库中的所有关系模式都属于 BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常\n\n\n6.2.7 多值依赖设  是属性集  上的一个关系模式。 是  的子集，并且 。关系模式  中多值依赖  成立，当且仅当对  的任一关系 ，给定的一对  值，有一组  的值，这组值仅仅决定于  值而与  值无关\n\n平凡多值依赖和非平凡的多值依赖\n若 ，而 ，即  为空，则称  为平凡的多值依赖\n否则称  为非平凡的多值依赖\n\n\n\n多值依赖的另一个等价的定义：在  的任一关系  中，如果存在元组  使得 ，那么就必然存在元组 ，（ 可以与  相同），使得 ，而 （即交换  元组的  值所得的两个新元组必在  中，则  多值依赖于 ，记为 。这里  是  的子集，\n多值依赖的性质：\n\n多值依赖具有对称性。即若 ，则 ，其中 \n多值依赖具有传递性。即若 ，， 则 \n函数依赖是多值依赖的特殊情况。即若 ，则 \n若 ，，则 \n若 ，，则 \n若 ，，则 \n\n多值依赖与函数依赖的区别\n\n多值依赖的有效性与属性集的范围有关，函数依赖X→Y的有效性仅决定于X、Y这两个属性集的值\n\n若  在 上成立，则在  上一定成立；反之则不然，即  在 上成立，在  上并不一定成立。\n\n原因：多值依赖的定义中不仅涉及属性组  和 ，而且涉及  中其余属性 \n\n一般地，在  上若有  在  上成立，则称  为  的嵌入型多值依赖\n\n\n\n若函数依赖  在  上成立，则对于任何  均有  成立。多值依赖 若在  上成立，不能断言对于任何  有  成立\n\n\n6.2.8 4NF关系模式 ，如果对于R的每个非平凡多值依赖， 都含有码，则 \n4NF 就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF 所允许的非平凡多值依赖实际上是函数依赖\n","categories":["数据库"]},{"title":"第六章 并发程序设计","url":"/2022/08/25/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter6.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258300&Signature=h9nWKnDXGD6GEVODburGTb9DgQI%3D\") \n\n","categories":["操作系统"]},{"title":"第八章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%85%AB%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%85%AB%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第六章 应用层","url":"/2022/06/06/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter6.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826935&Signature=LG3rTcNRakoeJYgV59PfbXtqVXY%3D\") ","categories":["计算机网络"]},{"title":"第六章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第五章 文件管理","url":"/2022/08/25/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter5.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258277&Signature=oJrKQK4/Rsutsm%2BLiSBBCom6zyY%3D\") \n","categories":["操作系统"]},{"title":"第十一章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第十三章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第十二章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第十六章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第十四章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第十五章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n\n","categories":["计基课后习题参考答案"]},{"title":"第十章习题参考答案","url":"/2022/07/06/%E7%AC%AC%E5%8D%81%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/","content":" location.replace(\" https://vohsiliu.gitee.io/fcs/answer/%E7%AC%AC%E5%8D%81%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88.pdf\") \n","categories":["计基课后习题参考答案"]},{"title":"第十章 数据库恢复技术","url":"/2022/06/06/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/","content":"第十章 数据库恢复技术10.1 事务的基本概念1. 事务\n事务（Transaction）是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位\n\n事务和程序是两个概念\n\n在关系数据库中，一个事务可以是一条 SQL 语句，一组 SQL 语句或整个程序\n一个程序通常包含多个事务\n\n\n事务是恢复和并发控制的基本单位\n\n\n定义事务的语句\nBEGIN TRANSACTION;\tSQL 语句\t……COMMIT;BEGIN TRANSACTION;\tSQL 语句\t……ROLLBACK;\n\n\n事务通常是以 BEGIN TRANSACTION 开始，以 COMMIT 或 ROLLBACK 结束\nCOMMIT 表示提交，即提交事务的所有操作，即将事务中所有对数据库的更新写回到磁盘上的物理数据库中，事务正常结束\nROLLBACK 表示事务运行的过程中发生了故障，不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销 ，回滚到开始时的状态\n\n\n\n2. 事务的ACID特性事务具有 4 个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability），保证事务 ACID 特性是事务处理的任务\n\n原子性\n\n事务是数据库的逻辑工作单位\n事务中包括的诸操作要么都做，要么都不做\n\n\n\n\n一致性\n\n事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态\n\n一致性状态\n\n数据库中只包含成功事务提交的结果\n\n\n不一致状态\n\n数据库系统运行中发生故障，有些事务尚未完成就被迫中断\n这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态\n\n\n\n\n隔离性\n\n一个事务的执行不能被其他事务干扰\n一个事务内部的操作及使用的数据对其他并发事务是隔离的\n并发执行的各个事务之间不能互相干扰\n\n\n持续性\n\n一个事务一旦提交，它对数据库中数据的改变就应该是永久性的\n接下来的其他操作或故障不应该对其执行结果有任何影响\n\n\n\n破坏事务 ACID 特性的因素\n\n多个事务并行运行时，不同事务的操作交叉执行\n\n数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性\n\n\n事务在运行过程中被强行停止\n\n数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响\n\n\n\n10.2 数据库恢复概述\n故障是不可避免的\n\n计算机硬件故障\n软件的错误\n操作员的失误\n恶意的破坏\n\n\n故障的影响\n\n运行事务非正常中断，影响数据库中数据的正确性 \n破坏数据库，全部或部分丢失数据\n\n\n数据库的恢复\n\n数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能，这就是数据库的恢复管理系统对故障的对策\n\n\n恢复子系统是数据库管理系统的一个重要组成部分 \n\n恢复技术是衡量系统优劣的重要指标\n\n\n10.3 故障的种类1. 事务内部的故障\n事务内部更多的故障是非预期的，是不能由应用程序处理的。\n\n运算溢出\n并发事务发生死锁而被选中撤销该事务\n违反了某些完整性限制而被终止等\n\n\n事务故障仅指这类非预期的故障\n\n事务故障意味着事务没有达到预期的终点（COMMIT 或者显式的 ROLLBACK），因此数据库可能处于不正确状态\n\n事务故障的恢复：事务撤消（UNDO）\n\n强行回滚（ROLLBACK）该事务\n撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样\n\n\n\n2. 系统故障\n系统故障，称为软故障，是指造成系统停止运转的任何事件（特定类型的硬件错误（如 CPU 故障）、操作系统故障、数据库管理系统代码错误、系统断电），使得系统要重新启动 \n\n整个系统的正常运行突然被破坏\n所有正在运行的事务都非正常终止\n不破坏数据库\n内存中数据库缓冲区的信息全部丢失\n\n\n发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态\n\n恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务\n\n\n发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失\n\n恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务\n\n\n\n3. 介质故障\n介质故障，称为硬故障，指外存故障\n\n磁盘损坏\n磁头碰撞\n瞬时强磁场干扰\n\n\n介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务\n\n介质故障比前两类故障的可能性小得多，但破坏性大得多\n\n\n4. 计算机病毒\n计算机病毒\n\n一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序\n可以繁殖和传播，造成对计算机系统包括数据库的危害\n\n\n计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁\n\n数据库一旦被破坏仍要用恢复技术把数据库加以恢复\n\n\n10.4 恢复的实现技术\n恢复操作的基本原理：冗余\n\n利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据\n\n\n恢复的实现技术：复杂\n\n一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上\n\n\n恢复机制涉及的关键问题\n\n如何建立冗余数据（数据转储，登记日志文件）\n如何利用这些冗余数据实施数据库恢复\n\n\n\n10.4.1 数据转储\n转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程\n\n备用的数据文本称为后备副本（backup）或后援副本\n\n数据库遭到破坏后可以将后备副本重新装入\n\n重装后备副本只能将数据库恢复到转储时的状态\n\n要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务\n\n\n\n\n转储可分为静态转储和动态转储\n\n静态转储\n\n在系统中无运行事务时进行的转储操作\n\n转储开始时数据库处于一致性状态\n\n转储期间不允许对数据库的任何存取、修改活动\n\n得到的一定是一个数据一致性的副本\n\n优点：实现简单\n\n缺点：降低了数据库的可用性\n\n转储必须等待正运行的用户事务结束 \n\n新的事务必须等转储结束\n\n\n\n\n\n动态转储\n\n转储操作与用户事务并发进行\n\n转储期间允许对数据库进行存取或修改\n\n优点\n\n不用等待正在运行的用户事务结束\n不会影响新事务的运行\n\n\n缺点：转储结束时后援副本上的数据并不能保证正确有效\n\n利用动态转储得到的副本进行故障恢复\n\n需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件\n\n后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态\n\n\n\n\n\n\n转储还可以分为海量转储和增量转储\n\n海量转储: 每次转储全部数据库\n\n增量转储: 只转储上次转储后更新过的数据\n\n海量转储与增量转储比较\n\n从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便\n如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效\n\n\n\n10.4.2 登记日志文件1. 日志文件的格式和内容日志文件是用来记录事务对数据库的更新操作的文件，日志文件主要有两种格式：以记录为单位的日志文件和以数据块为单位的日志文件\n\n对于以记录为单位的日志文件，日志文件中需要登记的记录包括\n\n各个事务的开始标记（BEGIN TRANSACTION）\n各个事务的结束标记（COMMIT 或 ROLLBACK）\n各个事务的所有更新操作\n上述三个内容均作为日志文件的一个日志记录，每个日志记录的主要内容包括\n事务标识（标明是哪个事务） \n操作类型（插入、删除或修改）\n操作对象（记录内部标识）\n更新前数据的旧值（对插入操作而言，此项为空值）\n更新后数据的新值（对删除操作而言, 此项为空值）\n\n\n\n\n对于以数据块为单位的日志文件，每条日志记录的内容包括事务标识和被更新的数据块\n\n\n2. 日志文件的作用\n事务故障恢复和系统故障恢复必须用日志文件\n\n在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库\n\n在静态转储方式中，也可以建立日志文件\n\n当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态\n利用日志文件，把已完成的事务进行重做处理\n对故障发生时尚未完成的事务进行撤销处理\n不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态\n\n\n\n\n\n3. 登记日志文件为保证数据库是可恢复的，登记日志文件时必须遵循两条原则\n\n登记的次序严格按并发事务执行的时间次序\n\n必须先写日志文件，后写数据库\n\n写日志文件操作：把表示这个修改的日志记录写到日志文件中\n写数据库操作：把对数据的修改写到数据库中\n\n\n\n先写日志文件的原因：\n\n写数据库和写日志文件是两个不同的操作\n\n在这两个操作之间可能发生故障\n\n如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了\n\n如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的 UNDO 操作，并不会影响数据库的正确性\n\n\n10.5 恢复策略10.5.1 事务故障的恢复","categories":["数据库"]},{"title":"第四章 数据库安全性","url":"/2022/06/06/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/","content":"第四章 数据库安全性4.1 数据库安全性概述4.1.1 数据库的不安全因素\n非授权用户对数据库的恶意存取和破坏\n一些黑客和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据\n数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术\n\n\n数据库中重要或敏感的数据被泄露\n黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露\n数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等\n审计日志分析\n\n\n安全环境的脆弱性\n数据库的安全性与计算机系统的安全性紧密联系\n建立一套可信计算机系统的概念和标准\n\n\n\n4.1.2 安全标准简介\nTCSEC/TDI 安全级别划分\n按系统可靠或可信程度逐渐增高\n各安全级别之间具有一种偏序向下兼容的关系\n\n\n\n\n\n\n安全级别\n定义\n\n\n\nA1\n验证设计（Verified Design）\n\n\nB3\n安全域（Security Domains）\n\n\nB2\n结构化保护（Structural Protection）\n\n\nB1\n标记安全保护（Labeled Security Protection）\n\n\nC2\n受控的存取保护（Controlled Access Protection）\n\n\nC1\n自主安全保护（Discretionary Security Protection）\n\n\nD\n最小保护（Minimal Protection）\n\n\n\nCC 评估保证级（EAL）划分\n\n\n\n\n评估保证级\n定义\nTCSEC安全级别（近似相当）\n\n\n\nEAL1\n功能测试（functionally tested）\n\n\n\nEAL2\n结构测试（structurally tested）\nC1\n\n\nEAL3\n系统地测试和检查（methodically tested and checked）\nC2\n\n\nEAL4\n系统地设计、测试和复查（methodically designed，tested，and reviewed）\nB1\n\n\nEAL5\n半形式化设计和测试（semiformally designed and tested）\nB2\n\n\nEAL6\n半形式化验证的设计和测试（semiformally verified design and tested）\nB3\n\n\nEAL7\n形式化验证的设计和测试（formally verified design and tested）\nA1\n\n\n4.2 数据库安全性控制\n4.2.1 用户身份鉴别\n静态口令鉴别\n动态口令鉴别\n生物特征鉴别\n智能卡鉴别\n\n4.2.2 存取控制\n定义用户权限，并将用户权限登记到数据字典中\n用户对某一数据对象的操作权力称为权限\nDBMS 提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则\n\n\n合法权限检查 \n用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统\nC2 级的数据库管理系统支持自主存取控制（Discretionary Access Control，DAC），B1 级的数据库管理系统支持强制存取控制（Mandatory Access Control，MAC）\n在自主存取控制方法中，用户对不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户\n在强制存取控制方法中，每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取\n\n\n\n4.2.3 自主存取控制方法\n通过 SQL 的 GRANT 语句和 REVOKE 语句实现\n用户权限由数据库对象和操作类型两个要素组成\n定义一个用户的存取权限就是要定义用户可以在哪些数据库对象上进行哪些类型的操作\n定义存取权限称为授权\n\n4.2.4 授权：授予与收回1. GRANTGRANT 语句的一般格式为\nGRANT &lt;权限&gt;[,&lt;权限&gt;]... ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]…TO &lt;用户&gt;[,&lt;用户&gt;]...[WITH GRANT OPTION];\n\n如果指定 WITH GRANT OPTION 子句，则获得某种权限的用户还可以把这种权限再授予其他的用户\n\n例：把查询Student表和修改学生学号的权限授给用户U4\n\nGRANT UPDATE(Sno), SELECT ON TABLE Student TO U4;\n\n2. REVOKEREVOKE 语句的一般格式为\nREVOKE &lt;权限&gt;[,&lt;权限&gt;]…ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…FROM &lt;用户&gt;[,&lt;用户&gt;]…[CASCADE | RESTRICT];\n\n4.2.5 数据库角色数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合\n1. 角色的创建CREATE ROLE &lt;角色名&gt;\n\n2. 给角色授权GRANT &lt;权限&gt;[,&lt;权限&gt;]… ON &lt;对象类型&gt;对象名  TO &lt;角色&gt;[,&lt;角色&gt;]…\n\n3. 将一个角色授予其他的角色或用户GRANT &lt;角色1&gt;[,&lt;角色2&gt;]…TO &lt;角色3&gt;[,&lt;用户1&gt;]… [WITH ADMIN OPTION]\n\n4. 角色权限的收回REVOKE &lt;权限&gt;[,&lt;权限&gt;]…ON &lt;对象类型&gt; &lt;对象名&gt;FROM &lt;角色&gt;[,&lt;角色&gt;]…\n\n4.2.6 强制存取控制方法\n在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类\n\n主体是系统中的活动实体：数据库管理系统所管理的实际用户，代表用户的各进程\n\n客体是系统中的被动实体，受主体操纵：文件、基本表、索引、视图\n\n对于主体和客体，DBMS 为它们每个实例（值）指派一个敏感度标记，敏感度标记分成若干级别，例如绝密（TS）、机密（S）、可信（C）和公开（P）等\n\n主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级\n\n强制存取控制规则\n\n仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体\n仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体\n\n\n强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据\n\n实现强制存取控制时要首先实现自主存取控制，因为较高安全性级别提供的安全保护要包含较低级别的所有保护\n\n\n4.3 视图机制\n把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护 \n间接地实现支持存取谓词的用户权限定义\n\n4.4 审计\n审计功能把用户对数据库的所有操作自动记录下来放入审计日志中\n审计员利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等\nC2 以上安全级别的 DBMS 必须具有审计功能\n审计功能的可选性\n审计很费时间和空间\nDBA 可以根据应用对安全性的要求，灵活地打开或关闭审计功能\n审计功能主要用于安全性要求较高的部门\n\n\n\n1. 审计事件审计事件一般有多个类别，例如\n\n服务器事件：审计数据库服务器发生的事件，包括数据库服务器的启动、停止、数据库服务器配置文件的重新加载\n\n系统权限：对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通过系统权限获得的\n\n语句事件：对 SQL 语句，如 DDL、DML、DQL 及 DCL 语句的审计\n\n模式对象事件：对特定模式对象上进行的 SELECT 或 DML 操作的审计\n\n\n2. 审计功能审计功能主要包括以下几个方面的内容：\n\n基本功能，提供多种审计查阅方式\n多套审计规则，一般在初始化设定\n提供审计分析和报表功能\n审计日志管理功能\n防止审计员误删审计记录，审计日志必须先转储后删除\n对转储的审计记录文件提供完整性和保密性保护\n只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录等\n\n\n提供查询审计设置及审计记录信息的专门视图\n\n3. AUDIT 语句和 NOAUDIT 语句AUDIT 语句用来设置审计功能，NOAUDIT 语句取消审计功能\n\n例：对修改 SC 表结构或修改 SC 表数据的操作进行审计\n\nAUDIT ALTER,UPDATE  ON  SC;\n\n4.5 数据加密\n数据加密是防止数据库中数据在存储和传输中失密的有效手段\n加密的基本思想是根据一定的算法将原始数据——明文变换为不可直接识别的格式­——密文\n加密方法\n存储加密\n透明存储加密\n内核级加密保护方式，对用户完全透明\n将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密\n数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可\n内核级加密方法：性能较好，安全完备性较高\n\n\n非透明存储加密\n通过多个加密函数实现\n\n\n\n\n传输加密\n链路加密\n在链路层进行加密\n传输信息由报头和报文两部分组成\n报文和报头均加密\n\n\n端到端加密\n在发送端加密，接收端解密\n只加密报文不加密报头\n所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息\n\n\n\n\n\n\n\n4.6 其他安全性保护\n推理控制：避免用户利用能够访问的数据推知更高密级的数据\n隐蔽信道：间接数据传递\n数据隐私保护：描述个人控制其不愿他人知道或他人不便知道的个人数据的能力\n\n","categories":["数据库"]},{"title":"第四章 网络层","url":"/2022/06/06/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/computer%20networking/chapter4.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719826884&Signature=o/CCI0cjGXUOUymmn5PBmuQ%2Bo0g%3D\") ","categories":["计算机网络"]},{"title":"第四章 设备管理","url":"/2022/08/17/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/chapter4.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1702258263&Signature=6R%2BDht5BONGn2L7vG6GXAKMN3jw%3D\") \n\n","categories":["操作系统"]},{"title":"线性代数笔记","url":"/2022/01/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/","content":" location.replace(\" https://vohsiliu.gitee.io/pdfblog/Linear%20Algebra.pdf\") \n","categories":["线性代数"]},{"title":"网站部署","url":"/2022/12/01/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/","content":" location.replace(\"https://blog.csdn.net/qq_35561857/article/details/81590953\") \n","categories":["编程环境安装和配置"]},{"title":"自动化测试MOOC习题答案","url":"/2022/11/07/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95MOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/automated%20testing/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95MOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1704202047&Signature=sr%2BeoUa/%2BA7pitDn%2ByYh6jAB3V0%3D\") \n","categories":["自动化测试"]},{"title":"自动化测试期末复习","url":"/2022/11/07/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/automated%20testing/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1704201996&Signature=2CaCGk9IhYQCMYoFatIHj8Tj6OE%3D\") \n","categories":["自动化测试"]},{"title":"设计模式","url":"/2023/01/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/design%20patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1705980442&Signature=%2BaKivp4TFATQimrwUDxqCvtgNMc%3D\") \n\n","categories":["设计模式"]},{"title":"设计模式期末复习","url":"/2023/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/design%20patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1719824974&Signature=pQ0i3tqB8p5dBgPtZ7gw2Yhs0BQ%3D\") ","categories":["设计模式"]},{"title":"质数筛","url":"/2022/06/06/%E8%B4%A8%E6%95%B0%E7%AD%9B/","content":"质数筛埃氏筛素数筛法，是一种快速“筛”出​​之间所有素数的方法。\n朴素的筛法叫埃氏筛（the Sieve of Eratosthenes，埃拉托色尼筛），它的过程是这样的：\n先将​​​​的数按顺序写出来：从前往后看，找到第一个未被划掉的数，是2，说明它是质数（这里是质数用标为蓝色表示）。然后把2的倍数（不包括2）划掉（这里划掉用标红表示）：\n下一个未被划掉的数是3，它是质数，然后把3的倍数划掉：接下来应该是5，但是由于5已经超过​了，所以遍历结束，剩下未被划掉的都是素数：这个过程用代码表示为：\nbool isPrime[MAXN+5] = {0};//标记数组 用来表示数字是否是质数：true表示是质数，false表示不是质数void aiPrime(int n){//埃氏筛处理n以内的质数\tmemset(isPrime,true,sizeof(isPrime));//所有数字，默认标记为质数 \tisPrime[1] = false;//修改1的状态，1不是质数\tfor(int i = 2; i * i &lt;= n; i++){//从2开始，枚举范围n以内的每个数字 \t\tif(isPrime[i]){//如果i是质数，则将n以内所有i的倍数（2倍及以上），标记为非质数 \t\t\tfor(int j = 2; j * i &lt;= n; j++){\t\t\t\tisPrime[j*i]=false;// 标记i的倍数为非质数 \t\t\t}\t\t}\t}}\n\n埃式筛算法的复杂度是 ​​，但是我们发现，在筛的过程中我们会重复筛到同一个数，例如12同时被2和3筛到，30同时被2、3和5筛到。\n所以我们引入欧拉筛，也叫线性筛，可以在​时间内完成对的筛选。它的核心思想是：让每一个合数被其最小质因数筛到。\n欧拉筛这次除了要把​列出来，还维护一个质数表：仍然是从头到尾遍历，第一个数是2，未被划掉，把它放进质数表：然后用2去乘质数表里的每个数，并且划掉它们：下一个是3，加入质数表，并用3去乘质数表里每一个数（此时是2和3），划掉6和9：下一个是4（注意：这里划掉的数也要遍历，只是不加入质数表），用4去乘质数表里每个数，划掉8，但不划掉12，因为​​，应该由它的最小质因数2筛掉，而不是3。实际上，对于数​，当遍历到质数表中的 ​ ，且发现 ​​（能整除）时，就应当停止遍历质数表。\n\n因为如果​​​​​​，即i%p == 0​，则说明假设在质数表中​​​​的下一位是​​​​​，设所以由有，因为，设所以​​​​​，则所以如果用​​式筛掉所以如果用3式筛去​​的话，当​​时，​​又会被​​​式筛去一次，为了确保合数只被最小质因子筛掉，最小质因子要乘以最大的倍数，即要乘以最大的​​, 所以不能提前筛。\n\n下一个数是5，加入质数表，划掉10和15：下一个数是6，划掉12，6能被2整除，跳过。\n……\n按这样的步骤进行下去，可以筛掉所有的合数，并得到一张质数表：我们可以保证每个合数都被筛过。设任意合数 ，其中是的最小质因数，又设，是的最小质因数。在处理时时，要遍历质数表，直到遇到时才结束，所以任意小于等于的质数与的乘积，都会在此时被筛掉。\n而由于一定有（因为的最小质因数是，而不是），所以在处理到时，一定会被筛到。\n代码如下：\nbool isPrime[MAXN+5];  int prime[MAXM+5];  //判断是否是一个素数  Mark 标记数组 index 素数个数  void olaPrime(){    int index = 0;    memset(isPrime,true,sizeof(isPrime));      for(int i = 2; i &lt; MAXSIZE; i++){           //如果i未被标记为非素数（即false）则得到一个素数          if(isPrime[i] == true){              prime[index++] = i;          }          //标记目前得到的素数的i倍为非素数          for(int j = 0; j &lt; index &amp;&amp; prime[j] * i &lt; MAXN; j++){               isPrime[i * prime[j]] = false;              if(i % prime[j] == 0){                  break;              }          }      }    }  //如果空间不够用质数表也可以不用开始就开到最大bool isnp[MAXN];//is not primevector&lt;int&gt; primes; // 质数表void olaPrime(int n){    for (int i = 2; i &lt;= n; i++){        if (!isnp[i]){            primes.push_back(i);        }        for (int p : primes){            if (p * i &gt; n){                break;            }            isnp[p * i] = 1;            if (i % p == 0){                break;            }        }    }}\n\n欧式筛的时间复杂度为。\n","categories":["数据结构与算法"]},{"title":"软件测试MOOC习题答案","url":"/2022/11/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95MOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/automated%20testing/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95MOOC%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1704202107&Signature=URfMYmLXxiT/Py3wvShlwIt%2BLAA%3D\") \n","categories":["自动化测试"]},{"title":"霍尔管程","url":"/2022/12/20/%E9%9C%8D%E5%B0%94%E7%AE%A1%E7%A8%8B/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E9%9C%8D%E5%B0%94%E7%AE%A1%E7%A8%8B.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995258&Signature=CgmoP7XDy3%2BGRdDgiq7t41n4iFE%3D\") ","categories":["操作系统"]},{"title":"需求工程","url":"/2022/12/25/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/requirement/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1706532371&Signature=7oPGwYVO2n4W819l1N4yucJ20iw%3D\") ","categories":["需求与商业模式创新"]},{"title":"面向服务的软件工程","url":"/2023/04/01/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/SOA/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1711712728&Signature=GSViIbrz9rSXievJg8IYiw53X78%3D\") ","categories":["面向服务的软件工程"]},{"title":"面向服务的软件工程选择题整理","url":"/2023/04/04/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/SOA/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%80%89%E6%8B%A9%E9%A2%98%E6%95%B4%E7%90%86.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1711712879&Signature=z6qHLrivHJIvKyCBOL0p9BVjJAI%3D\") ","categories":["面向服务的软件工程"]},{"title":"高精度运算","url":"/2022/06/06/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/","content":"基础数据处理函数void moveFrontZero(string &amp;a){//去除一个字符串的前导0\ta.erase(0,a.find_first_not_of('0'));\tif(a.empty()){        a = \"0\";    }}void align(string &amp;a, string &amp;b){//让两个字符串变成相同的长度，长度小的补0\tint a_size = a.size();\tint b_size = b.size();\tif(a_size &lt; b_size){\t\tfor(int i = 1; i &lt;= b_size - a_size; i++){\t\t\ta = \"0\" + a;\t\t}\t}else{\t\tfor(int i = 1; i &lt;= a_size-b_size; i++){\t\t\tb = \"0\" + b;\t\t}\t}}\n\n高精度加法string add(string addent, string adder){\tmoveFrontZero(addent);\tmoveFrontZero(adder);\tstring answer = \"\";\talign(addent,adder);\tint temp = 0, carry = 0;//temp表示当前对位相加结果，carry表示进位\tfor(int i = addent.size() - 1; i &gt;= 0; i--){\t\ttemp = addent[i] - '0' + adder[i] - '0' + carry;\t\tcarry = temp/10;\t\ttemp %= 10;\t\tanswer = (char)(temp + '0') + answer;\t}\tif(carry){//处理最高位相加可能产生的进位        answer = (char)(carry + '0') + answer;    }\tmoveFrontZero(answer);\treturn answer;}\n\n高精度减法string sub(string subtrahend, string subtractor){//顺序是被减数和减数\tmoveFrontZero(subtrahend);\tmoveFrontZero(subtractor);\talign(subtrahend,subtractor);\tbool is_minus = false;\tif(subtrahend &lt; subtractor){\t\tis_minus = true;\t\tsubtrahend.swap(subtractor);//确保大数减小数\t}\tstring answer = \"\";\tint temp = 0,carry = 0;//temp表示当前对位相减结果，carry表示借位\tfor(int i = subtrahend.size() - 1; i &gt;= 0; i--){\t\tif(subtrahend[i] - carry &lt; subtractor[i]){//被减数不够减的情况\t\t\ttemp = subtrahend[i] - carry + 10 - subtractor[i];\t\t\tcarry = 1;\t\t\tanswer = (char)(temp +'0') + answer;\t\t}else{//被减数够减\t\t\ttemp = subtrahend[i] - carry - subtractor[i];\t\t\tcarry = 0;\t\t\tanswer = (char)(temp +'0') + answer;\t\t}\t}\tmoveFrontZero(answer);\tif(is_minus)answer = \"-\"+answer;\treturn answer;}\n\n高精度乘法（需要依赖高精度加法）乘法的主要思想是把乘法转化为加法进行运算。以下面具体的例子说明：\n\n\n等式（1）​说明，多位数乘一位数，可以直接使用加法完成。\n等式（2）说明，多位数乘形如的数，可以转换成多位数乘一位数来处理。\n等式（3）说明，多位数乘多位数，可以转换为若干个多位数乘形如的数与多位数乘一位数之和。\n因此，多位数乘多位数最终可以全部用加法来实现。\nstring mul(string multiplicand, string multiplier){    //multiplicand表示被乘数，即上面例子中的12345，multiplier是乘数，即上面例子的24    string answer = \"0\";//answer必须初始化为“0”    for (int i = (int) multiplier.length() - 1; i &gt;= 0 ; i--) {        for (char c = '1'; c &lt;= multiplier[i]; c++) {            answer = add(answer, multiplicand);        }        multiplicand = multiplicand + \"0\";    }    moveFrontZero(answer);\treturn answer;}\n\n高精度除法（需要依赖高精度减法）//试商法string div(string dividend, string divisor){\tmoveFrontZero(dividend);\tmoveFrontZero(divisor);\tstring answer = \"\";\tstring reminder = \"\";\treminder.append(dividend,0,divisor.size()-1);//截取被除数从首位到除数位数的前一位\tfor(int i = divisor.size() - 1; i &lt; dividend.size(); i++){\t\treminder = reminder + dividend[i];\t\tmoveFrontZero(reminder);\t\tfor(char j = '9';j &gt;= '0'; j--){\t\t\tstring temp = \"\";\t\t\ttemp = temp + j;\t\t\ttemp = mul(divisor,temp);\t\t\talign(temp,reminder);\t\t\tif(temp &lt;= reminder){\t\t\t\tanswer = answer + j;\t\t\t\treminder = sub(reminder,temp);\t\t\t\tbreak;\t\t\t}\t\t}\t}\t    moveFrontZero(answer);\t//cout  &lt;&lt;  \"reminder=\"  &lt;&lt;  reminder  &lt;&lt;  endl;\treturn answer;}\n\n高精度阶乘（利用高精度减法和乘法实现）string factorial(string a){//高精度阶乘（最大可运行出10000左右的阶乘）    moveFrontZero(a);\tif(a == \"1\"){\t\treturn a;    }\telse \t\treturn mul(a,factorial(sub(a,\"1\")));//即利用递归转化为a*(a-1)!}\n\n","categories":["数据结构与算法"]},{"title":"页面替换算法","url":"/2022/12/20/%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95/","content":" location.replace(\"https://thiller.obs.cn-north-4.myhuaweicloud.com:443/OS/%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95.pdf?AccessKeyId=L4GDLJP2NZ8QPKVQLEQJ&Expires=1707995120&Signature=cVWdk8hLduEeDwv3K5i/TpHb/bw%3D\") ","categories":["操作系统"]},{"title":"第一章 计算机系统漫游","url":"/2022/06/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/","content":"第一章 计算机系统漫游以hello程序的生命周期为例来开始对系统的学习\n#include &lt;stdio.h&gt;int main(){  printf(\"hello, world\\n\");  return 0;}\n\n\n1.1 信息就是位+上下文\nhello.c程序是以字节序列的方式存储在文件中的，大部分计算机系统都用ASCII标准\n\n系统中的所有信息都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。\n1.2 程序被其他程序翻译成不同的格式\nGCC读取hello.c文件并将其翻译为可执行目标文件hello共分为4个阶段，执行这4个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统\n\n\n预处理阶段 ：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序，得到另一个.i文件。\n\n编译阶段 ：编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。\n\n汇编阶段 ：汇编器（as）将hello.s文件翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在hello.o中\n\n链接阶段 ： hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器（ld）就负责处理这种合并。结果就得到hello文件，它是一个可执行目标文件（可执行文件），可以被加载到内存中，由系统执行。\n\n\n1.3 了解编译系统如何工作是大有益处的\n\n优化程序性能\n\n理解链接时出现的错误\n\n避免安全漏洞\n\n\n1.4 处理器读并解释储存在内存中的指令\n1.4.1 系统的硬件组成\n\n总线 ：贯串整个系统的一组电子管道。它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字 ，字中的字节数（字长 ）是一个基本的系统参数，大多数为64位。\n\nI/O设备 ：每个I/O设备都通过一个控制器 或适配器 与I/O总线相连。控制器和适配器的区别主要在于它们的封装方式，控制器是I/O本身或者系统的主印制电路板（主板 ）上的芯片组，适配器是一块插在主板插槽上的卡。\n\n主存 ：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器 （dynamic random access memory，DRAM）芯片组成的；从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。\n\n处理器 ：中央处理单元 （CPU），简称处理器，是解释或执行存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器 （PC）。在任何时候，PC都指向主存中的某条机器语言指令，即含有该条指令的地址。\n\n\n从系统通电开始，直到系统断电，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。\n1.4.2 运行hello程序初始时，在Linux系统中，shell程序执行它的指定，等待输入命令。当在键盘上输入字符串”./hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。\n\n在键盘敲回车键，即结束命令输入后，shell执行一系列将hello目标文件中的代码和数据从磁盘复制到主存。利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从硬盘到达主存，这个步骤如下图所示。\n\n\n一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器指令，将“hello, world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上，该步骤如下图所示。\n\n\n1.5 高速缓存至关重要\n针对处理器和主存之间的差异，系统设计者采用更小更快的存储设备，称为高速缓存存储器 （cache memory，简称为cache或高速缓存），作为暂时的集结区域，存放处理器可能会需要的信息。处理能力强的系统可能会有三级高速缓存：L1、L2和L3使系统获得更大的存储器，同时访问速度更快，原因是利用了高速缓存的局部性 原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。\n\n1.6 存储设备形成层次结构\n每个计算机系统中的存储设备都被组织成了一个存储器层次结构 ，在这个结构中，从上至下，设备的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越便宜。\n\n\n存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。\n1.7 操作系统管理硬件\n在hello例子中，shell和hello程序都没有直接访问键盘、显示器、磁盘或主存，它们依靠操作系统 提供的服务。可以把操作系统看作是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。\n\n操作系统有两个基本功能 ：\n1.防止硬件被失控的应用程序滥用；\n2.向应用程序提供简单一致的机制来控制复杂而又通常大而不同的低级硬件设备。\n操作系统通过几个基本的抽象概念（进程 、虚拟内存 和文件 ）来实现这两个功能。\n\n1.7.1 进程进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以运行多个进程，而每个进程都好像在单独地使用硬件。而并发运行 ，则是说一个进程的指令和另一个进程的指令是交错执行的。一个CPU看上去都像是在并发的执行多个进程，这是通过处理器在进程间切换实现的。操作系统实现这种交错执行的机制称为上下文切换 （上下文是指操作系统保持跟踪进程运行所需的所有状态信息）。下图展示了hello程序运行场景的基本理念。\n\n\n示例场景中有两个并发的进程：shell进程和hello进程。最开始，只有shell进程在运行，即等待命令行上的输入。当让它运行hello程序时， shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传给新的hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给它， shell进程会继续等待下一个命令行输入。\n从一个进程到另一个进程的转换是由操作系统内核 管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用 指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合。\n1.7.2 线程1.一个进程实际上可以由多个称为线程 的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。\n2.因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。\n1.7.3 虚拟内存虚拟内存为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间 。下图是Linux进程的虚拟地址空间，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有的进程来说都是一样的；底部区域存放用户进程定义的代码和数据。\n\n\n\n程序代码和数据   对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。\n\n堆   代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。\n\n共享库   大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。\n\n栈   位于用户虚拟地址空间顶部的是用户栈 ，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每当调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。\n\n内核虚拟内存   地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。\n\n\n虚拟内存运行的基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。\n1.7.4 文件文件就是字节序列。每个I/O设备都可以看成是文件。系统中所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。\n1.8 系统之间利用网络通信\n\n\n对于hello程序，可以用telnet应用在一个远程主机上运行hello程序。假设用本地主机上的telnet客户端连接远程主机上的telnet服务器，在登陆到远程主机并运行shell后的步骤如下图所示。\n\n1.9 重要主题\n1.9.1 Amdahl定律Amadahl定律的主要思想是，当对系统的某部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。\n设系统执行某应用程序需要时间为，系统某部分所需执行时间与该时间的比例为​，该部分性能提升比例为，所以总的执行时间为，所以加速比为\n可以看到，虽然对系统一个主要部分做出重大改进，但获得的系统加速比却远小于这部分的加速比，这就是Amdahl定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。\n1.9.2 并发和并行并发（concurrency）是指一个同时具有多个活动的系统；并行（parallelism）指的是用并发来使一个系统运行得更快。\n下面按照系统层次结构由高到低顺序强调并行的三个层次：\n1. 线程级并发 \n\n\n如下图，多核处理器是将多个CPU（称为“核”）集成到一个集成电路芯片上。下图中的微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中L1高速缓存分为两个部分，一个保存最近取到的指令，另一个放数据。这些核共享更高层次的高速缓存，以及到主存的接口。\n\n\n超线程（有时称为同时多线程）是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器；而其他的硬件部分只有一份，比如执行浮点算数运算的单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。\n多处理器的使用从（1）减少在执行多个任务时模拟并发的需要；（2）使应用程序运行的更快 两个方面提高系统性能。\n2. 指令级并行 \n在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行 。\n在流水线 中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。\n如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量 处理器。\n3. 单指令、多数据并行 \n在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据 ，即SIMD并行。\n提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。\n可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC就支持向量数据类型。\n1.9.3 计算机系统中抽象的重要性\n\n指令集架构 提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上；\n文件 是对I/O设备的抽象；\n虚拟内存 是对程序存储器的抽象；\n进程 是对一个正在运行的程序的抽象；\n虚拟机 提供对整个计算机的抽象，包括操作系统、处理器和程序\n1.10 小结\n计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件。\n处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。\n操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：\n\n文件是对I/O设备的抽象；\n\n虚拟内存是对主存和磁盘的抽象；\n\n进程是处理器、主存和I/O设备的抽象。\n\n\n最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。\n","categories":["CSAPP笔记"]},{"title":"第七章 数据库设计","url":"/2022/06/06/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","content":"第七章 数据库设计7.1 数据库设计概述\n数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求\n\n信息管理要求：在数据库中应该存储和管理哪些数据对象\n数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作\n\n\n数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境\n\n数据库数据的存取效率高\n数据库存储空间的利用率高\n数据库系统运行管理的效率高\n\n\n\n7.1.1 数据库设计的特点1. 数据库建设的基本规律\n“三分技术，七分管理，十二分基础数据”\n管理\n数据库建设项目管理 \n企业（即应用部门）的业务管理\n\n\n基础数据\n数据的收集、整理、组织和不断更新\n\n\n\n2. 结构（数据）设计和行为（处理）设计相结合\n将数据库结构设计和数据处理设计密切结合\n\n结构和行为分离的设计\n\n传统的软件工程：重行为设计，忽视对应用中数据语义的分析和抽象，只要有可能就尽量推迟数据结构设计的决策\n早期的数据库设计：重结构设计，致力于数据模型和数据库建模方法研究，忽视了行为设计对结构设计的影响\n\n\n\n7.1.2 数据库设计方法\n大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。\n\n它要求多方面的知识和技术。主要包括：\n\n计算机的基础知识\n软件工程的原理和方法\n程序设计的方法和技巧\n数据库的基本知识\n数据库设计技术\n应用领域的知识\n\n\n手工试凑法\n\n规范设计法\n\n新奥尔良（New Orleans）方法\n基于 E-R 模型的数据库设计方法\n3NF（第三范式）的设计方法\n面向对象的数据库设计方法\n统一建模语言（UML）方法\n\n\n\n7.1.3 数据库设计的基本步骤\n\n数据库设计各个阶段的数据设计描述\n\n\n7.1.4 数据库设计过程中的各级模式\n\n7.2 需求分析7.2.1 需求分析的任务\n详细调查现实世界要处理的对象（组织、部门、企业等）\n\n充分了解原系统（手工系统或计算机系统）工作概况\n\n明确用户的各种需求\n\n在此基础上确定新系统的功能\n\n新系统必须充分考虑今后可能的扩充和改变\n\n调查的重点是“数据”和“处理”，获得用户对数据库的要求\n\n信息要求\n\n用户需要从数据库中获得信息的内容与性质\n由信息要求可以导出数据要求，即在数据库中需要存储哪些数据\n\n\n处理要求\n\n用户要完成的处理功能\n对处理性能的要求\n\n\n安全性与完整性要求\n\n\n\n确定用户最终需求的难点\n\n用户缺少计算机知识，不能准确地表达自己的需求，他们所提出的需求往往不断地变化\n设计人员缺少用户的专业知识，不易理解用户的真正需求，甚至误解用户的需求\n\n\n解决方法\n\n设计人员必须不断深入地与用户进行交流，才能逐步确定用户的实际需求\n\n\n7.2.2 需求分析的方法\n调查组织机构情况\n调查各部门的业务活动情况\n协助用户明确对新系统的各种要求，包括信息要求、处理要求、完全性与完整性要求\n确定新系统的边界\n\n\n\n7.2.3 数据字典\n数据字典是关于数据库中数据的描述，即元数据，不是数据本身\n\n数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善\n\n数据字典是进行详细的数据收集和数据分析所获得的主要结果\n\n数据字典的内容\n\n数据项\n数据结构\n数据流\n数据存储\n处理过程\n\n\n数据项是数据的最小组成单位\n\n若干个数据项可以组成一个数据结构\n\n数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容\n\n\n1. 数据项\n数据项是不可再分的数据单位\n\n对数据项的描述：数据项描述={数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系}\n\n“取值范围”、“与其他数据项的逻辑关系”定义了数据的完整性约束条件，是设计数据检验功能的依据\n可以用关系规范化理论为指导，用数据依赖的概念分析和表示数据项之间的联系\n\n\n\n2.数据结构\n数据结构反映了数据之间的组合关系。\n一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成\n对数据结构的描述：数据结构描述={数据结构名，含义说明，组成：{数据项或数据结构}}\n\n3. 数据流\n数据流是数据结构在系统内传输的路径\n\n对数据流的描述：数据流描述={数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}\n\n数据流来源：说明该数据流来自哪个过程\n数据流去向：说明该数据流将到哪个过程去\n平均流量：在单位时间（每天、每周、每月等）里的传输次数\n高峰期流量：在高峰时期的数据流量\n\n\n\n4. 数据存储\n数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。\n对数据存储的描述：数据存储描述={数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存取频度，存取方式}\n存取频度：每小时、每天或每周存取次数，每次存取的数据量等信息 \n存取方法：批处理 / 联机处理；检索 / 更新；顺序检索 / 随机检索\n输入的数据流：数据来源\n输出的数据流：数据去向\n\n\n\n5. 处理过程\n处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明性信息\n\n处理过程说明性信息的描述：处理过程描述={处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}\n\n简要说明：说明该处理过程的功能及处理要求\n功能：该处理过程用来做什么\n处理要求：处理频度要求，如单位时间里处理多少事务，多少数据量、响应时间要求等\n处理要求是后面物理设计的输入及性能评价的标准\n\n\n\n\n\n7.3 概念结构设计7.3.1 概念模型\n将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计\n\n概念模型的特点：\n\n能真实、充分地反映现实世界，是现实世界的一个真实模型\n易于理解，从而可以用它和不熟悉计算机的用户交换意见\n易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充\n易于向关系、网状、层次等各种数据模型转换\n\n\n描述概念模型的工具：E-R模型\n\n\n7.3.2 E-R模型1. 实体之间的联系（1）两个实体型之间的联系\n一对一联系（）：如果对于实体集 A 中的每一个实体，实体集 B 中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集 A 与实体集 B 具有一对一联系，记为\n\n一对多联系（）：如果对于实体集 A 中的每一个实体，实体集 B 中有  个实体（）与之联系，反之，对于实体集 B 中的每一个实体，实体集 A 中至多只有一个实体与之联系，则称实体集 A 与实体集 B 有一对多联系，记为\n\n多对多联系（）:如果对于实体集 A 中的每一个实体，实体集 B 中有  个实体（）与之联系，反之，对于实体集 B 中的每一个实体，实体集 A 中也有  个实体（）与之联系，则称实体集 A 与实体集 B 具有多对多联系，记为\n\n\n\n\n（2）两个以上的实体型之间的联系两个以上的实体型之间也存在着一对一、一对多、多对多联系\n\n\n（3）单个实体型内的联系同一个实体集内的各实体之间也可以存在一对一、一对多、多对多的联系\n\n\n2. E-R图E-R图提供了表示实体型、属性和联系的方法：\n\n实体型：用矩形表示，矩形框内写明实体名\n\n属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来\n\n联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（、 或 ）\n\n联系可以具有属性\n\n\n7.3.3 拓展的E-R模型1. ISA联系\n有的实体型是某个实体型的子类型，这种父类—子类联系称为 ISA 联系，表示“is a”语义。用△表示\n\nISA联系的性质: 子类继承了父类的所有属性，子类也可以有自己的属性\n\n\n（1）分类属性\n分类属性是父实体型的一个属性\n\n分类属性的值把父实体型中的实体分派到子实体型中\n\n\n\n\n（2）不相交约束与可重叠约束\n不相交约束：描述父类中的一个实体不能同时属于多个子类中的实体集。即一个父类中的实体最多属于一个子类实体集\n\n用 ISA 联系符号三角形内加一个叉号“X”来表示\n\n可重叠约束：父类中的一个实体能同时属于多个子类中的实体集。子类符号中没有叉号表示是可重叠的\n\n\n\n\n（3）完备性约束\n描述父类中的一个实体是否必须是某一个子类中的实体。\n\n如果是，则叫做完全特化（total specialization）\n否则叫做部分特化（partial specialization）\n\n\n完全特化用父类到子类的双线连接来表示\n\n部分特化用父类到子类的单线连接来表示\n\n\n2. 基数约束\n说明实体型中的任何一个实体可以在联系中出现的最少次数和最多次数\n\n对实体之间一对一、 一对多、多对多联系的细化\n\n约束用一个数对  表示，。例如 $0..1,1..3,1..，其中$ 代表无穷大\n\n 的约束叫做强制参与约束，即被施加基数约束的实体型中的每个实体都要参与联系\n\n 的约束叫做非强制参与约束，被施加基数约束的实体型中的实体可以出现在联系中，也可以不出现在联系\n\n\n3. Part-of 联系\n描述某个实体型是另外一个实体型的一部分\n\nPart-of 联系可以分为两种情况：\n\n非独占的 Part-of 联系，简称非独占联系\n\n整体实体如果被破坏，另一部分实体仍然可以独立存在\n\n\n独占的 Part-of 联系， 简称独占联系\n\n整体实体如果被破坏，部分实体不能存在\n\n\n\n\nPart-of 联系的表示\n\n用非强制参与联系表示非独占的 Part-of 联系\n用弱实体类型和识别联系来表示独占联系编号\n\n\n如果一个实体型的存在依赖于其它实体型的存在，则这个实体型叫做弱实体型，否则叫做强实体型\n\n用弱实体类型和识别联系来表示独占联系双矩形表示弱实体型，用双菱型表示识别联系\n\n\n7.3.4 概念结构设计1. 实体与属性的划分原则\n作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性\n\n属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系\n\n\n2. E-R图的集成E-R 图的集成一般需要分两步\n\n合并。解决各分 E-R 图之间的冲突，将分 E-R 图合并起来生成初步 E-R 图\n修改和重构。消除不必要的冗余，生成基本 E-R 图\n\n（1）合并E-R图，生成初步E-R图各个局部应用所面向的问题不同，各个子系统的 E-R 图之间必定会存在许多不一致的地方，称之为冲突\n子系统 E-R 图之间的冲突主要有三类：\n\n属性冲突\n\n属性域冲突，即属性值的类型、取值范围或取值集合不同\n\n属性取值单位冲突\n\n\n\n命名冲突\n\n同名异义，即不同意义的对象在不同的局部应用中具有相同的名字\n\n异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字\n\n\n\n结构冲突\n\n同一对象在不同应用中具有不同的抽象\n解决方法：把属性变换为实体或把实体变换为属性，使同一对象具有相同的抽象。但仍然要遵循实体与属性的划分原则\n\n\n同一实体在不同子系统的 E-R 图中所包含的属性个数和属性排列次序不完全相同\n解决方法：使该实体的属性取各子系统的 E-R 图中属性的并集，再适当调整属性的次序\n\n\n实体间的联系在不同的 E-R 图中为不同的类型\n\n\n\n（2）消除不必要的冗余，设计基本E-R图\n所谓冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系\n\n消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余\n\n\n7.4 逻辑结构设计7.4.1 E-R图向关系模型的转换\n一个  联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并\n一个  联系可以转换为一个独立的关系模式，也可以与  端对应的关系模式合并\n一个  联系转换为一个关系模式，与该联系相连的各实体部分的码以及联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系码的一部分\n三个或三个以上实体间的一个多元联系转换为一个关系模式\n具有相同码的关系模式可合并\n\n7.4.2 数据模型的优化关系数据模型的优化通常以规范化理论为指导，方法为：\n\n确定数据依赖\n对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系\n按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式\n按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解\n对关系模式进行必要分解，提高数据操作效率和存储空间的利用率\n\n7.4.3 设计用户子模式\n定义数据库模式主要是从系统的时间效率、空间效率、易维护等角度出发。\n\n定义用户外模式时应该更注重考虑用户的习惯与方便。包括三个方面：\n\n使用更符合用户习惯的别名\n合并各分 E-R 图曾做了消除命名冲突的工作，以使数据库系统中同一关系和属性具有唯一的名字。这在设计数据库整体结构时是非常必要的\n用视图机制可以在设计用户视图时可以重新定义某些属性名，使其与用户习惯一致，以方便使用\n\n\n针对不同级别的用户定义不同的视图，以保证系统的安全性\n简化用户对系统的使用\n如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图\n\n\n\n\n\n7.5 数据库的物理设计\n数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统\n\n为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计\n\n数据库物理设计的步骤\n\n确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构\n对物理结构进行评价，评价的重点是时间和空间效率\n\n\n若评价结果满足原设计要求，则可进入到物理实施阶段。否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型\n\n\n7.5.1 数据库物理设计的内容和方法\n设计物理数据库结构的准备工作\n\n充分了解应用环境，详细分析要运行的事务，以获得选择物理数据库设计所需参数\n充分了解所用关系型数据库管理系统的内部特征，特别是系统提供的存取方法和存储结构\n\n\n关系数据库物理设计的内容\n\n为关系模式选择存取方法\n设计关系、索引等数据库文件的物理存储结构\n\n\n物理数据库设计所需参数\n\n数据库查询事务\n查询的关系\n查询条件所涉及的属性\n连接条件所涉及的属性\n查询的投影属性\n\n\n数据更新事务\n被更新的关系\n每个关系上的更新操作条件所涉及的属性\n修改操作要改变的属性值\n\n\n每个事务在各关系上运行的频率和性能要求\n\n\n\n7.5.2 关系模式存取方法选择\n数据库系统是多用户共享的系统，对同一个关系要建立多条存取路径才能满足多用户的多种应用要求。\n物理结构设计的任务之一是根据关系数据库管理系统支持的存取方法确定选择哪些存取方法。\n数据库管理系统常用存取方法\nB+ 树索引存取方法\nHash 索引存取方法\n聚簇存取方法\n\n\n\n1. B+树索引存取方法的选择\n选择索引存取方法的主要内容：根据应用要求确定对哪些属性列建立索引、对哪些属性列建立组合索引、对哪些索引要设计为唯一索引\n\n选择索引存取方法的一般规则\n\n如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）\n如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引\n如果一个（或一组）属性经常在连接操作的连接条件中出现，则考虑在这个（或这组）属性上建立索引\n\n\n关系上定义的索引数过多会带来较多的额外开销（维护、查找索引的开销）\n\n\n2. Hash索引存取方法的选择选择 Hash 存取方法的规则\n\n如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一\n该关系的大小可预知，而且不变\n该关系的大小动态改变，但所选用的数据库管理系统提供了动态 Hash 存取方法\n\n\n\n3. 聚簇存取方法的选择\n为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇。\n\n该属性（或属性组）称为聚簇码（cluster key）\n\n聚簇的用途：大大提高按聚簇属性进行查询的效率\n\n聚簇既适用于单个关系，也适用于经常进行连接操作的多个关系\n\n把多个连接的元组按连接属性值聚集存放\n从而实现多个关系的“预连接”，提高连接操作的效率\n\n\n聚簇存储方法的选择\n\n选择聚簇存储方法，即确定需要建立多少个聚簇，每个聚簇中包含哪些关系（一个数据库可以建立多个聚簇，一个关系只能加入一个聚簇）\n\n设计候选聚簇\n\n常在一起进行连接操作的关系可以建立组合聚簇\n如果一个关系的一组属性经常出现在相等比较条件中，则该单个关系可建立聚簇\n如果一个关系的一个（或一组）属性上的值重复率很高，则此单个关系可建立聚簇\n\n\n检查候选聚簇中的关系，取消其中不必要的关系\n\n从聚簇中删除经常进行全表扫描的关系\n从聚簇中删除更新操作远多于连接操作的关系\n从聚簇中删除重复出现的关系\n当一个关系同时加入多个聚簇时，必须从这多个聚簇方案（包括不建立聚簇）中选择一个较优的，即在这个聚簇上运行各种事务的总代价最小。\n\n\n\n\n\n\n聚簇的局限性\n\n聚簇只能提高某些特定应用的性能\n建立与维护聚簇的开销相当大\n对已有关系建立聚簇，将导致关系中元组的物理存储位置移动，并使此关系上原有的所有索引无效，必须重建\n当一个元组的聚簇码改变时，该元组的存储位置也要做相应改变\n\n\n当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的时，可以使用聚簇\n尤其当 SQL 语句中包含有与聚簇码有关的 ORDER BY，GROUP BY，UNION，DISTINCT 等子句或短语时，使用聚簇特别有利，可以省去或减化对结果集的排序操作\n\n\n\n\n\n7.5.3 确定数据库的存储结构\n确定数据库物理结构主要指确定数据的存放位置和存储结构，包括：确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等\n\n影响数据存放位置和存储结构的因素\n\n硬件环境\n应用需求\n存取时间\n存储空间利用率\n维护代价\n\n\n\n\n\n7.5.4 评价物理结构\n对数据库物理设计过程中产生的多种方案进行评价，从中选择一个较优的方案作为数据库的物理结构。\n\n评价方法\n\n定量估算各种方案\n\n存储空间\n\n存取时间\n\n维护代价\n\n\n\n对估算结果进行权衡、比较，选择出一个较优的合理的物理结构\n\n\n\n\n7.6 数据库的实施和维护7.6.1 数据的载入和应用程序的调试\n数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作\n\n数据装载方法\n人工方法\n计算机辅助数据入库\n\n\n\n\n数据库应用程序的设计应该与数据设计并行进行\n\n在组织数据入库的同时还要调试应用程序\n\n\n\n7.6.2 数据库的试运行\n应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试，也称数据库的试运行\n\n主要工作包括：\n\n功能测试：实际运行应用程序，执行对数据库的各种操作，测试应用程序的各种功能\n性能测试：测量系统的性能指标，分析是否符合设计目标\n\n\n数据库性能指标的测量\n\n数据库物理设计阶段在评价数据库结构估算时间、空间指标时，作了许多简化和假设，忽略了许多次要因素，因此结果必然很粗糙\n数据库试运行则是要实际测量系统的各种性能指标（不仅是时间、空间指标），如果结果不符合设计目标，则需要返回物理设计阶段，调整物理结构，修改参数；有时甚至需要返回逻辑设计阶段，调整逻辑结构\n\n\n数据库的试运行的注意事项：\n\n数据的分期入库\n重新设计物理结构甚至逻辑结构，会导致数据重新入库\n由于数据入库工作量实在太大，所以可以采用分期输入数据的方法\n先输入小批量数据供先期联合调试使用\n待试运行基本合格后再输入大批量数据\n逐步增加数据量，逐步完成运行评价\n\n\n\n\n数据库的转储和恢复\n在数据库试运行阶段，系统还不稳定，硬、软件故障随时都可能发生\n系统的操作人员对新系统还不熟悉，误操作也不可避免\n因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏\n\n\n\n\n\n7.6.3 数据库的运行和维护在数据库运行阶段，对数据库经常性的维护工作主要是由数据库管理员完成的，包括：\n\n数据库的转储和恢复\n数据库的安全性、完整性控制\n数据库性能的监督、分析和改进\n数据库的重组织与重构造\n\n1. 数据库的转储和恢复\n数据库管理员要针对不同的应用要求制定不同的转储计划，定期对数据库和日志文件进行备份\n\n一旦发生故障，即利用数据库备份及日志文件备份，尽快将数据库恢复到某种一致性状态。并尽可能减少对数据库的破坏\n\n\n2. 数据库的安全性、完整性控制\n初始定义\n\n数据库管理员根据用户的实际需要授予不同的操作权限\n根据应用环境定义不同的完整性约束条件\n\n\n修改定义\n\n当应用环境发生变化，对安全性的要求也会发生变化，数据库管理员需要根据实际情况修改原有的安全性控制\n由于应用环境发生变化，数据库的完整性约束条件也会变化，也需要数据库管理员不断修正，以满足用户要求\n\n\n\n3. 数据库性能的监督、分析和改进在数据库运行过程中，数据库管理员必须监督系统运行，对监测数据进行分析，找出改进系统性能的方法\n\n利用监测工具获取系统运行过程中一系列性能参数的值\n\n通过仔细分析这些数据，判断当前系统是否处于最佳运行状态\n\n如果不是，则需要调整参数或对数据库进行重组织或重构造\n\n\n4. 数据库的重组织与重构造为什么要重组织数据库\n\n数据库运行一段时间后，由于记录的不断增、删、改，会使数据库的物理存储变坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降\n\n重组织的形式\n\n全部重组织\n\n部分重组织\n\n只对频繁增、删的表进行重组织\n\n\n\n重组织的目标\n\n提高系统性能\n\n重组织的工作\n\n按原设计要求\n\n重新安排存储位置\n回收垃圾\n减少指针链\n\n\n数据库的重组织不会改变原设计的数据逻辑结构和物理结构\n\n\n数据库管理系统一般都提供了供重组织数据库使用的实用程序，帮助数据库管理员重新组织数据库\n为什么要进行数据库的重构造\n\n数据库应用环境发生变化，会导致实体及实体间的联系也发生相应的变化，使原有的数据库设计不能很好地满足新的需求\n增加新的应用或新的实体\n取消某些已有应用\n改变某些已有应用\n\n\n\n重构造的主要工作\n\n根据新环境调整数据库的模式和内模式\n增加或删除某些数据项\n改变数据项的类型\n增加或删除某个表\n改变数据库的容量\n增加或删除某些索引\n\n\n\n重构造数据库的程度是有限的\n\n若应用变化太大，已无法通过重构数据库来满足新的需求，或重构数据库的代价太大，则表明现有数据库应用系统的生命周期已经结束，应该重新设计新的数据库应用系统了\n\n","categories":["数据库"]},{"title":"第三章 关系数据库标准语言SQL","url":"/2022/06/06/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL/","content":"第三章 关系数据库标准语言SQL3.1 SQL概述\n结构化查询语言（Structured Query Language，SQL），是关系数据库的标准语言，也是一个通用的、功能极强的关系数据库语言\n目前没有一个数据库系统能够支持 SQL 标准的所有概念和特性\n许多软件厂商对 SQL 基本命令集还进行了不同程度的扩充和修改，又可以支持标准以外的一些功能特性\nSQL 的特点\n综合统一\n高度非过程化\n面向集合的操作方式\n以同一种语法结构提供多种使用方式\n语言简洁，易学易用\n\n\n支持 SQL 的关系数据库管理系统同样支持关系数据库三级模式结构，其中外模式包含若干视图和部分基本表，模式包括若干基本表，内模式包含若干存储文件\n基本表\n本身独立存在的表\nSQL 中一个关系就对应一个基本表\n一个（或多个）基本表对应一个存储文件\n一个表可以带若干索引\n\n\n存储文件\n逻辑结构组成了关系数据库的内模式\n物理结构对用户是隐蔽的\n\n\n视图\n从一个或几个基本表导出的表\n数据库中只存放视图的定义而不存放视图对应的数据\n视图是一个虚表\n用户可以在视图上再定义视图\n\n\n\n\n\n\n\n3.2 数据定义\n层次化的数据库对象命名机制\n\n一个关系数据库管理系统的实例中可以建立多个数据库\n一个数据库中可以建立多个模式\n一个模式下通常包括多个表、视图和索引等数据库对象\n\n\n\n\n\n\n\nSQL 的数据定义功能\n\n\n\n\n操作对象\n创建\n删除\n修改\n\n\n\n模式\nCREATE SCHEMA\nDROP SCHEMA\n\n\n\n表\nCREATE TABLE\nDROP TABLE\nALTER TABLE\n\n\n视图\nCREATE VIEW\nDROP VIEW\n\n\n\n索引\nCREATE INDEX\nDROP INDEX\nALTER INDEX\n\n\n3.2.1 模式的定义与删除1. 定义模式\n定义模式实际上定义了一个命名空间。在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等\nSQL 中模式定义语句为\n\nCREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;;\n\n\n在CREATE SCHEMA中可以接受 CREATE TABLE，CREATE VIEW 和 GRANT 子句，即\n\nCREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [&lt;表定义子句&gt; | &lt;视图定义子句&gt; | &lt;授权定义子句&gt;]\n\n2. 删除模式\nSQL 中删除模式的语句为\n\nDROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;;\n\n\n其中 CASCADE 和 RESTRICT 两者必选其一\n选择了 CASCADE（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除\n选择了 RESTRICT （限制），表示如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。仅当该模式中没有任何下属的对象时才能执行 DROP SCHEMA 语句\n\n\n\n3.2.2 基本表的定义、删除与修改1. 定义基本表SQL 中定义基本表的格式为\nCREATE TABLE &lt;表名&gt;      (&lt;列名&gt; &lt;数据类型&gt; [&lt;列级完整性约束条件&gt;]      [,&lt;列名&gt; &lt;数据类型&gt;[&lt;列级完整性约束条件&gt;]]    \t\t…      [,&lt;表级完整性约束条件&gt;]);\n\n\n&lt;表名&gt;：所要定义的基本表的名字\n&lt;列名&gt;：组成该表的各个属性（列）\n&lt;列级完整性约束条件&gt;：涉及相应属性列的完整性约束条件\n&lt;表级完整性约束条件&gt;：涉及一个或多个属性列的完整性约束条件 \n如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级\n\n2. 数据类型\nSQL 中域的概念用数据类型来实现\n定义表的属性时需要指明其数据类型及长度 \n一个属性选用哪种数据类型一般从取值范围和要做哪些运算两方面来考虑\n\n3. 修改基本表SQL 中修改基本表的格式为\nALTER TABLE &lt;表名&gt;[ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]][ADD &lt;表级完整性约束&gt;][DROP [COLUMN] &lt;列名&gt; [CASCADE | RESTRICT]][DROP CONSTRAINT &lt;完整性约束名&gt; [RESTRICT | CASCADE]][ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;];\n\n\n&lt;表名&gt;是要修改的基本表\n\nADD 子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件\n\nDROP COLUMN 子句用于删除表中的列\n\n如果指定了 CASCADE 短语，则自动删除引用了该列的其他对象\n\n如果指定了 RESTRICT 短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列\n\n\n\nDROP CONSTRAINT 子句用于删除指定的完整性约束条件\n\nALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型\n\n\n4. 删除基本表SQL 删除基本表的格式为\nDROP TABLE &lt;表名&gt; [RESTRICT| CASCADE];\n\n\n若选择 RESTRICT，则删除表是有限制的：欲删除的基本表不能被其他表的约束所引用，如果存在依赖该表的对象，则此表不能被删除\n若选择 CASCADE，删除该表没有限制：在删除基本表的同时，相关的依赖对象一起删除\n\n3.2.3 索引的建立和删除\n建立索引的目的：加快查询速度\n\n由数据库管理员或表的拥有者建立\n由关系数据库管理系统自动完成维护\n关系数据库管理系统自动使用合适的索引作为存取路径，用户不必也不能显式地选择索引\n\n\n关系数据库管理系统中常见索引：\n\n顺序文件上的索引\nB+树索引\n散列索引\n位图索引\n\n\n\n1. 建立索引建立索引的语句格式为\nCREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;次序&gt;] [,&lt;列名&gt; [&lt;次序&gt;]]…);\n\n\n&lt;表名&gt;：要建索引的基本表的名字\n索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔\n&lt;次序&gt;：指定索引值的排列次序，升序为 ASC，降序为 DESC，缺省值为 ASC\nUNIQUE：此索引的每一个索引值只对应唯一的数据记录\nCLUSTER：表示要建立的索引是聚簇索引\n\n2. 修改索引对于以建立的索引，如果需要对其重新命名，语句格式为\nALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;\n\n3. 删除索引删除索引的语句格式为\nDROP INDEX &lt;索引名&gt;;\n\n3.2.4 数据字典\n数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息：\n\n关系模式定义\n视图定义\n索引定义\n完整性约束定义\n各类用户对数据库的操作权限\n统计信息等\n\n\n关系数据库管理系统在执行 SQL 的数据定义语句时，实际上就是在更新数据字典表中的相应信息\n\n\n3.3 数据查询SQL 提供了 SELETE 语句进行数据查询，该语句具有灵活的使用方式和丰富的功能，其一般格式为\nSELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [,&lt;目标列表达式&gt;] …FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;…] | (SELECT语句) [AS] &lt;别名&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC | DESC]];\n\n\nSELECT 子句：指定要显示的属性列\nFROM 子句：指定查询对象（基本表或视图）\nWHERE 子句：指定查询条件\nGROUP BY 子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。\nHAVING 短语：只有满足指定条件的组才予以输出\nORDER BY 子句：对查询结果表按指定列值的升序或降序排序\n\n以下例子均来源于下图的学生-课程数据库\n\n3.3.1 单表查询1. 选择表中的若干列（1）查询指定列\n\n例：查询全体学生的学号与姓名\n\nSELECT Sno, SnameFROM Student; \n\n（2）查询全部列\n\n例：查询全体学生的详细记录\n\nSELECT  *FROM Student;\n\n（3）查询经过计算的值\n\n例：查询全体学生的姓名、出生年份和所在的院系，要求用小写字母表示系名，且使用列别名改变查询结果的列标题\n\nSELECT Sname NAME, 'Year of Birth:' BIRTH, 2014-Sage BIRTHDAY, LOWER(Sdept) DEPARTMENTFROM Student;\n\n查询结果为：（当前年为2014年）\n\n\n\nNAME\nBIRTH\nBIRTHDAY\nDEPARTMENT\n\n\n\n李勇\nYear of Birth:\n1994\ncs\n\n\n刘晨\nYear of Birth:\n1995\ncs\n\n\n王敏\nYear of Birth:\n1996\nma\n\n\n张立\nYear of Birth:\n1995\nis\n\n\n2. 选择表中的若干元组（1）消除取值重复的行\n\n例：查询选修了课程的学生学号\n\nSELECT DISTINCT SnoFROM SC; \n\n（2）查询满足条件的元组\n\n例：查询计算机系年龄在20岁以下的学生姓名\n\nSELECT SnameFROM  StudentWHERE Sdept = 'CS' AND Sage &lt; 20;\n\n3. ORDER BY 子句\n例：查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列\n\nSELECT  *FROM  StudentORDER BY Sdept, Sage DESC;  \n\n4. 聚集函数\n例：计算1号课程的学生平均成绩\n\nSELECT AVG(Grade)FROM    SCWHERE Cno= ' 1 ';\n\n5. GROUP BY 子句\n例：查询平均成绩大于等于90分的学生学号和平均成绩\n\nSELECT  Sno, AVG(Grade)FROM  SCGROUP BY SnoHAVING AVG(Grade) &gt;= 90;\n\n3.3.2 连接查询1. 等值与非等值连接查询\n例：查询每个学生及其选修课程的情况\n\nSELECT  Student.*, SC.*FROM    Student, SCWHERE   Student.Sno = SC.Sno;\n\n2. 自身连接\n例：查询每一门课的间接先修课（即先修课的先修课）\n\nSELECT  FIRST.Cno, SECOND.CpnoFROM  Course  FIRST, Course  SECOND #为Course表取两个别名，一个是FIRST，另一个是SECONDWHERE FIRST.Cpno = SECOND.Cno;\n\n3. 外连接\n例：查询每个学生及其选修课程的情况，保留没有选课的学生\n\nSELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,GradeFROM  Student  LEFT OUT JOIN SC ON (Student.Sno=SC.Sno); \n\n4. 多表连接\n例：查询每个学生的学号、姓名、选修的课程名及成绩\n\nSELECT Student.Sno, Sname, Cname, GradeFROM    Student, SC, CourseWHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno;\n\n3.3.3 嵌套查询\n一个 SELECT-FROM-WHERE 语句称为一个查询块\n\n将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为嵌套查询\n\n子查询不能使用 ORDER BY 子句\n\n不相关子查询：子查询的查询条件不依赖于父查询\n\n由里向外，逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。\n\n\n相关子查询：子查询的查询条件依赖于父查询\n\n首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表\n然后再取外层表的下一个元组\n重复这一过程，直至外层表全部检查完为止\n\n\n\n1. 带有 IN 谓词的子查询\n例：查询选修了课程名为“信息系统”的学生学号和姓名\n\nSELECT  Sno,Sname                 FROM    Student                          WHERE Sno  IN\t\t\t(SELECT Sno                     \t\t\t FROM    SC                      \t\t\t WHERE  Cno IN\t\t\t\t\t\t(SELECT Cno            \t\t\t\t\t\t FROM Course          \t\t\t\t\t\t WHERE Cname= '信息系统'\t\t\t\t\t\t)\t\t\t);\n\n2. 带有比较运算符的子查询\n例：找出每个学生超过他选修课程平均成绩的课程号\n\nSELECT  Sno, CnoFROM    SC  xWHERE Grade &gt;= (SELECT AVG（Grade） \t\t            FROM  SC y\t\t            WHERE y.Sno=x.Sno);\n\n3. 带有 ANY（SOME）或 ALL 谓词的子查询\n例：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄\n\nSELECT  Sname,SageFROM    StudentWHERE   Sage &lt;ANY (SELECT  Sage                   FROM    Student                   WHERE   Sdept= ' CS ')AND Sdept &lt;&gt; ‘CS ‘ ;/*注意这是父查询块中的条件 */\n\n4. 带有 EXISTS 谓词的子查询\n例：查询所有选修了1号课程的学生姓名\n\nSELECT SnameFROM   StudentWHERE  EXISTS       (SELECT *        FROM SC        WHERE Sno=Student.Sno AND Cno= '1');\n\n3.3.4 集合查询\n集合操作主要包括并操作 UNION、交操作 INTERSECT 和差操作 EXCEPT\n参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同\n\n\n例：查询选修了课程1或者选修了课程2的学生\n\nSELECT SnoFROM SCWHERE Cno = '1'UNIONSELECT SnoFROM SCWHERE Cno = '2';\n\n\n例：查询计算机科学系的学生与年龄不大于19岁的学生的交集（MySQL目前不支持交操作）\n\nSELECT *FROM StudentWHERE Sdept = 'CS' INTERSECTSELECT *FROM StudentWHERE Sage &lt;= 19 \n\n实际上就是查询计算机科学系中年龄不大于19岁的学生\nSELECT *FROM StudentWHERE Sdept = 'CS' AND Sage &lt;= 19;\n\n\n例：查询计算机科学系的学生与年龄不大于19岁的学生的差集（MySQL目前不支持差集操作）\n\nSELECT *FROM StudentWHERE Sdept='CS'EXCEPTSELECT  *FROM StudentWHERE Sage &lt;=19;\n\n实际上是查询计算机科学系中年龄大于19岁的学生\nSELECT *FROM StudentWHERE Sdept = 'CS' AND Sage &gt; 19;\n\n3.3.5 基于派生表的查询\n子查询不仅可以出现在 WHERE 子句中，还可以出现在 FROM 子句中，这时子查询生成的临时派生表成为主查询的查询对象\n如果子查询中没有聚集函数，派生表可以不指定属性列，子查询 SELECT 子句后面的列名为其默认属性\n通过 FROM 子句生成派生表时，AS 关键字可以省略，但必须为派生关系指定一个别名\n\n\n例：找出每个学生超过他自己选修课程平均成绩的课程号\n\nSELECT Sno, CnoFROM SC, (SELECT Sno, Avg(Grade)           FROM SC    \t\t  GROUP BY Sno)          AS Avg_sc(avg_sno,avg_grade)WHERE SC.Sno = Avg_sc.avg_sno and SC.Grade &gt;= Avg_sc.avg_grade\n\n3.3.6 SELECT 语句的一般格式SELECT 语句的一般格式为\nSELECT [All|DISTINCT] &lt;目标表达式&gt; [别名] [,&lt;目标表达式&gt;[别名]]…FROM &lt;表名或视图名&gt; [别名] [,&lt;表名或视图名&gt; [别名]] … | (&lt;SELECT&gt;) [AS] &lt;别名&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC|DESC]]\n\n\n目标列表达式的可选格式\n\n*\n&lt;表名&gt;. *\nCOUNT ([DISTINCT|ALL])\n&lt;表名或视图名&gt; [别名] [,&lt;表名或视图名&gt; [别名]] …\n\n\n聚集函数的一般格式\n\n\nMissing or unrecognized delimiter for \\left \\left{ \\begin{aligned}[l] &amp; \\mathrm{COUNT} \\ &amp; \\mathrm{SUM}\\ &amp; \\mathrm{AVG}\\ &amp; \\mathrm{MAX}\\ &amp; \\mathrm{MIN} &amp; \\end{aligned} \\right} \\ ([\\mathrm{DISTINCT,  |,  ALL}] \\ \\mbox{&lt;列名&gt;}) \n\nWHERE 子句的条件表达式的可选格式\n\nMissing or unrecognized delimiter for \\left \\mbox{&lt;属性列名&gt;} \\uptheta\\left{ \\begin{aligned}[l] &amp; \\mbox{&lt;属性列名&gt;} &amp;\\ &amp; \\mbox{&lt;常量&gt;} \\ &amp; [\\mathrm{ANY} , |, \\mathrm{ALL}]\\ (\\mathrm{SELECT}, \\mbox{语句}) \\end{aligned} \\right} \n\nMissing or unrecognized delimiter for \\left \\mbox{&lt;属性列名&gt;} \\mathrm{[NOT]\\ BETWEEN}\\left{ \\begin{aligned}[l] &amp; \\mbox{&lt;属性列名&gt;} &amp;\\ &amp; \\mbox{&lt;常量&gt;} \\ &amp; (\\mathrm{SELECT}, \\mbox{语句}) \\end{aligned} \\right} \\ \\mathrm{AND}\\  \\left{ \\begin{aligned}[l] &amp; \\mbox{&lt;属性列名&gt;} &amp;\\ &amp; \\mbox{&lt;常量&gt;} \\ &amp; (\\mathrm{SELECT}, \\mbox{语句}) \\end{aligned} \\right} \n\n$$\\mbox{&lt;属性列名&gt;} \\mathrm{[NOT]\\ IN}\\left{\\begin{aligned}[l]&amp; (\\mbox{&lt;值1&gt; \\ [,&lt;值2&gt; …]}) \\\n&amp; (\\mathrm{SELECT}, \\mbox{语句})\\end{aligned}\\right}$$\n\n&lt;属性列名&gt; [NOT] LIKE &lt;匹配串&gt;\n\n&lt;属性列名&gt; IS [NOT] NULL\n\n[NOT] EXISTS (SELECT语句)\n\nMissing or unrecognized delimiter for \\left \\mbox{&lt;条件表达式&gt;} \\left{ \\begin{aligned}[l] &amp;\\mathrm{AND}  \\ &amp;\\mathrm{OR} \\end{aligned} \\right}\\ \\mbox{&lt;条件表达式&gt;} \\left( \\left{ \\begin{aligned}[l] &amp;\\mathrm{AND}  \\ &amp;\\mathrm{OR} \\end{aligned} \\right}\\mbox{&lt;条件表达式&gt;}… \\right) \n\n\n\n\n3.4 数据更新3.4.1 插入数据1. 插入元组插入元组的 INSERT 语句的格式为\nINSERTINTO &lt;表名&gt; [(&lt;属性列1&gt;[,&lt;属性列2&gt; …)]VALUES (&lt;常量1&gt;[,&lt;常量2&gt;] …);\n\n\n对于INTO 子句\n\n指定要插入数据的表名及属性列\n属性列的顺序可与表定义中的顺序不一致\n没有指定属性列时，表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致\n指定部分属性列时，插入的元组在其余属性列上取空值\n\n\n对于 VALUES 子句，提供的值的个数和值的类型必须与 INTO 子句匹配\n\n\n\n例：将一个新学生元组插入到 Student 表中\n\nINSERTINTO  Student (Sno,Sname,Ssex,Sdept,Sage)VALUES ('201215128','陈冬','男','IS',18);\n\n2. 插入子查询结果插入子查询结果的 INSERT 语句格式为\nINSERT INTO &lt;表名&gt; [(&lt;属性列1&gt; [,&lt;属性列2&gt;…)]子查询;\n\n\n例：对每一个系，求学生的平均年龄，并把结果存入数据库\n\n首先在数据库中建立一个新表，其中一列存放系名，另一列存放相应的学生平均年龄\nCREATE TABLE Dept_age            (Sdept CHAR(15)                                      Avg_age SMALLINT)\n\n然后对 Student 按系分组求平均年龄，再把系名和平均年龄存入新表中\n3.4.2 修改数据修改操作又称为更新操作，其语句的一般格式为\nUPDATE &lt;表名&gt;SET &lt;列名&gt; = &lt;表达式&gt;[,&lt;列名&gt; = &lt;表达式&gt;]…[WHERE &lt;条件&gt;];\n\n\n其功能是修改指定表中满足 WHERE 子句条件的元组\nSET 子句给出&lt;表达式&gt;的值用于取代相应的属性列\n如果省略 WHERE 子句，表示要修改表中的所有元组\n\n\n例：将计算机科学系全体学生的成绩置零\n\nUPDATE SCSET Grade=0WHERE Sno IN\t\t (SELETE Sno      FROM Student      WHERE Sdept = 'CS');\n\n3.4.3 删除数据删除语句的一般格式为\nDELETEFROM &lt;表名&gt;[WHERE &lt;条件&gt;];\n\n\nDELETE 语句的功能是从指定表中删除满足 WHERE 子句条件的所有元组\n如果省略 WHERE 语句则表示删除表中的所有元组，但表的定义仍在字典中\nDELETE 语句删除的是表中的数据，而不是关于表的定义\n\n\n例：删除计算机科学系所有学生的选课记录\n\nDELETEFROM SCWHERE Sno IN\t\t\t(SELETE  Sno\t\t\tFROM  Student\t\t\tWHERE Sdept = 'CS');\n\n3.5 空值的处理\n空值就是“不知道”或“不存在”或“无意义”的值\n\nSQL 语言允许某些元组的某些属性在一定情况下取空值，一般有以下几种情况：\n\n该属性应该有一个值，但目前不知道它的具体值\n该属性不应该有值\n由于某种原因不便于填写\n\n\n空值是一个很特殊的值，含有不确定性。对关系运算带来特殊的问题，需要做特殊的处理\n\n\n1.空值的产生\n\n例：向SC表中插入一个元组，学生号是“201215126”，课程号是”1”，成绩为空\n\nINSERT INTO SC(Sno,Cno,Grade)VALUES('201215126', '1', NULL);   \n\n2.空值的判断\n\n例：从Student表中找出漏填了数据的学生信息\n\nSELECT  *FROM StudentWHERE Sname IS NULL OR Ssex IS NULL OR Sage IS NULL OR Sdept IS NULL;\n\n3.空值的约束条件\n属性定义（或者域定义）中有 NOT NULL 约束条件的不能取空值，加了 UNIQUE 限制的属性不能取空值，码属性不能取空值\n4.空值的算数运算、比较运算和逻辑运算\n\n空值与另一个值（包括另一个空值）的算术运算的结果为空值\n\n空值与另一个值（包括另一个空值）的比较运算的结果为 UNKNOWN\n\n有 UNKNOWN 后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑\n\n\n\n\n\n在查询语句中，只有使 WHERE 和 HAVING 子句的选择条件为 TRUE 的元组才被选出作为输出结果\n\n\n例：选出选修1号课程的不及格的学生以及缺考的学生\n\nSELECT SnoFROM SCWHERE Cno = '1' AND (Grade &lt; 60 OR Grade IS NULL);/*或者*/SELECT SnoFROM SCWHERE Grade &lt; 60 AND Cno = '1'UNIONSELECT SnoFROM SCWHERE Grade IS NULL AND Cno = '1'\n\n3.6 视图\n视图是从一个或几个基本表（或视图）导出的虚表\n数据库中只存放视图的定义，而不存放视图对应的数据\n一旦基表中的数据发生变化，从视图中查询出的数据也随之改变\n\n3.6.1 定义视图3.6.1.1 建立视图SQL 语言用 CREATE VIEW 命令建立视图，其一般格式为\nCREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…)]AS &lt;子查询&gt;[WITH CHECK OPTION];\n\n\n子查询可以是任意的 SELECT 语句，是否可以含有 ORDER BY 子句和 DISTINCT 短语，则取决于具体系统的实现\nWITH CHECK OPTION 表示对视图进行 UPDATE，INSERT 和 DELETE 操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）\n组成视图的属性列名或者全部省略或者全部指定\n如果省略了视图的各个属性列名，则隐含该视图由子查询中 SELECT 子句目标列中的诸字段组成\n下列情况必须指定组成视图的所有列名\n某个目标列是聚集函数或列表达式\n多表连接时选出了几个同名列作为视图的字段\n需要在视图中为某个列启用新的更合适的名字\n\n\n\n\n例：建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生\n\nCREATE VIEW IS_StudentAS SELECT Sno, Sname, SageFROM  StudentWHERE  Sdept = 'IS'WITH CHECK OPTION;\n\n3.6.1.2 删除视图删除视图的语句格式为\nDROP VIEW &lt;视图名&gt;[CASCADE];\n\n\n该语句从数据字典中删除指定的视图定义\n如果该视图上还导出了其他视图，使用 CASCADE 级联删除语句，把该视图和由它导出的所有视图一起删除 \n删除基表时，由该基表导出的所有视图定义都必须显式地使用 DROP VIEW 语句删除\n\n3.6.2 查询视图关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图等是否存在。如果存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后在执行修正了的查询。这一转换过程称为视图消解。\n\n例：查询选修了1号课程的信息系学生\n\nSELECT IS_Student.Sno,SnameFROM IS_Student,SCWHERE IS_Student.Sno = SC.Sno AND SC.Cno = '1';\n\n3.6.3 更新视图\n由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换成对基本表的更新\n像查询视图一样，对视图的更新操作也是通过视图消解，转换为对基本表的更新操作\n一般地，行列子集视图是可更新的\n对其他类型视图的更新不同系统有不同限制。一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新\n\n\n例：将信息系学生视图 IS_Student 中学号“201215122”的学生姓名改为”刘辰”\n\nUPDATE IS_StudentSET Sname= '刘辰'WHERE Sno = '201215122';\n\n转换后的更新语句为：\nUPDATE StudentSET Sname = '刘辰'WHERE Sno = '201215122' AND Sdept = 'IS';\n\n3.6.4 视图的作用\n视图能够简化用户的操作\n视图使用户能以多种角度看待同一数据，适应数据库共享的需要\n视图对重构数据库提供了一定程度的逻辑独立性\n视图能够对机密数据提供安全保护\n适当的利用视图可以更清晰的表达查询\n\n","categories":["数据库"]},{"title":"第三章 程序的机器级表示","url":"/2022/06/06/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","content":"第三章 程序的机器级表示计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。\n3.1 程序编码\n假设一个C程序，有两个文件p1.c和p2.c。用Unix命令行编译这些代码：\nlinux&gt; gcc -0g -o p p1.c p2.c\n\n\n\n命令gcc指的就是GCC C编译器。因为这是Linux上默认的编译器，也可以简单地用cc来启动它。\n编译选项-0g告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。\n实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项-01或-02指定）被认为是较好的选择。\n\n实际上gcc命令调用了一整套的程序，将源代码转化为可执行代码：\n\n首先， C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏。\n其次，编译器产生两个源文件的汇编代码，名字分别为p1.s和p2.s。\n接下来，汇编器会将汇编代码转化成二进制目标代码文件p1.o和p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。\n最后，链接器将两个目标代码文件与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件p（由命令行指示符-o p指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。\n\n\n\n3.1.1 机器级代码对于机器级编程来说，其中两种抽象尤为重要：\n\n由指令集体系结构或指令集架构（Instruction Set Architecture, ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA, 包括x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。\n机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。\n\nx86-64的机器代码中一些通常对C语言程序员隐藏的处理器状态都是可见的：\n\n程序计数器（通常称为“PC”，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址。\n整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言中的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。\n条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，例如用来实现if和while语句。\n一组向量寄存器可以存放一个或多个整数或浮点数值。\n\n机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。\n程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用malloc库函数分配的）。程序内存用虚拟地址来寻址。\n3.1.2 代码示例1. 编译器\nC语言代码文件mstore.c中包含如下的函数定义\nlong mult2(long, long);void multstore(long x,long y,long *dest){  long t = mult2(x,y);  *dest = t;}\n\n\n在命令行上运行linux&gt; gcc -0g -S mstore.c产生一个汇编文件mstore.s：\n         .file   \"010-mstore.c\"         .text            .globl  multstore         .type   multstore,@fuctionmultstore:                  pushq   %rbx         movq    %rbx, %rbx         call    mult2         movq    %rax, (%rbx)         popq    %rbx         ret         .size   multstore, .-multstore         .ident  \"GCC:(Ubuntu 4.8.1-2ubuntu1~12.04)4.8.1\"         .section       .note.GNU-stack,\"\",@progbits     \n\n\n所有以“.”开头的行都是指导汇编器和连接器工作的伪指令，通常可以忽略这些行。为了更清楚地说明汇编代码，用这样一种格式来表示汇编代码，它省略了大部分伪指令，但包括行号和解释性说明。对于本例该代码如下：\nvoid multstore(long x, long y, long *dest)x in %!r(MISSING)di, y in %!r(MISSING)si, dest in %!r(MISSING)dxmultstore:    pushq     %rbx             Save %!r(MISSING)bx    moveq     %rbx, %rbx       Copy dest to %!r(MISSING)bx    call      mult2            Call mult2(x,y)    movq      %rax, (%rbx)     Store result at *dest    popq      %rbx             Restore %!r(MISSING)bx    ret                        Return\n\n\n汇编代码相比C语言有以下特点：\n\n有许多不同类型的整型数据类型，它们存储时不区分符号和无符号\n指针是以简单的数字的形式保存在计算机中的\n浮点数以和整型数据完全不同的方式进行处理，并且使用完全不同的寄存器组\n程序本身是一系列字节\n机器级别并不存在类似数组和结构这样的基本数据类型，它们是由编译器构成的\n汇编语言中的每条语言能做的都非常有限\n变量所有名称在汇编代码级别完全丢失了，变成了寄存器和内存中的某个位置\n\n2.汇编器\n运行gcc -Og -c mstore.c来进行编译和汇编，会生成二进制文件mstore.o，它是对一系列指令的编码，机器直接执行这些字节序列，而对源代码一无所知。\n可以通过反汇编器来将机器代码转化为类似汇编代码的格式，在Linux中，运行objdump -d mstore.o，可以得到：\nDisassembly of function multstore in binary file mstore.o0000000000000000 &lt;multstore&gt;Offset   Byte                     Equivalent assembly language    0:   53                       push      %rbx    1:   48 89 d3                 move      %rbx, %rbx    4:   e8 00 00 00 00           callq     9 &lt;multstore+0x9&gt;    9:   48 89 03                 mov       %rax, (%rbx)    c:   5b                       pop      %rbx    d:   c3                       retq\n\n\n最左侧一栏是对应的字节地址，中间是每个指令的编码，右侧是等价的汇编语言。其中一些关于机器代码和它的反汇编表示的特性值得注意：\n\nx86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。\n设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq  %rbx是以字节值53开头的。\n反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。\n反汇编器使用的指令命名规则与GCC 生成的汇编代码使用的有些细微的差别。在示例中，它省略了很多指令结尾的‘q’。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call和ret指令添加了‘q’后缀，同样，省略这些后缀也没有问题。\n\n3.链接器\n生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数。假设在文件main.c中有下面这样的函数：\n#include &lt;stdio.h&gt;void multstore(long, long ,long*)int main(){  long d;  multstore(2, 3, &amp;d);  printf(\"2 * 3 --&gt; %ld\\n\",d);  return 0;}long mult2(long a, long b){  long s = a * b;  return s;} \n\n\n然后运行命令linux&gt; gcc -0g -o prog main.c mstore.c将main.c和mstore.c链接起来，并添加启动和终止程序的代码，以及用来与操作系统交互的代码生成可执行代码，最终生成可执行文件prog。通过对其反汇编，可以得到如下内容：\nDisassembly of function sum multstore binary file prog0000000000400540 &lt;multstore&gt;400540:   53                       push      %rbx400541:   48 89 d3                 move      %rbx, %rbx400544:   e8 42 00 00 00           callq     40058b &lt;mult2&gt;400549:   48 89 03                 mov       %rax, (%rbx)40054c:   5b                       pop       %rbx40054d:   c3                       retq40054e:   90                       nop40054f:   90                       nop\n\n\n可以看出，这段代码与mstore.c反汇编产生的代码的区别有：\n\n左边列出的地址不同，链接器将这段代码的地址移到了一段不用的地址范围中\n链接器填上了callq指令调用函数mult2需要使用的地址（第5行）。链接器的任务之一就是为函数调用找到匹配的函数可执行代码的位置。\n多了两行代码（第9和10行）。插入这些指令是为了使函数代码变为16字节，使得就存储器系统性能而言，能更好地放置下一个代码块。\n\n3.2 数据格式\n\n大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和movq（传送四字）。注意，汇编代码使用后缀‘l’来表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。\n3.3 访问信息\n一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。这些寄存器都用来存储整数数据和指针，名字都以%r开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。\n\n\n当指令以寄存器作为目标时，对于生成小于8字节结果的指令，对于寄存器中剩下的字节会怎么样有两条规则：生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0。\n有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。\n3.3.1 操作数指示符大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据可以以常数形式给出，或是从寄存器或内存中读出，结果可以存放在寄存器或内存中。\n\n各种不同的操作数的可能性被分为三种类型：\n1.立即数（immediate），用来表示常数值。书写方式是‘$’后跟一个用标准C表示法的整数。不同指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。\n2.寄存器（register），表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数。用符号表示任意寄存器，用引用表示它的值。\n3.内存（memory）引用，根据计算出来的地址（通常称为有效地址）访问某个内存位置。用符号表示对存储在内存中从地址开始的个字节值的引用，通常省去下标。\n有多种不同的寻址模式，允许不同形式的内存引用。是最常用的形式。这个引用有四个组成部分：一个立即数偏移，一个基址寄存器，一个变址寄存器和一个比例因子且必须是1、2、4或8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为。其他形式都是这种通用形式的特殊情况。\n3.3.2 数据传送指令最频繁的指令是将数据从一个位置复制到另一个位置的指令。\n\n\n源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。\n大多数情况中， MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。\n在下面的MOV指令示例中，第一个是源操作数，第二个是目的操作数。\nmovl $0x4050,%eax                Immediate--Register, 4 bytesmovw %bp,%sp                     Register--Register,  2 bytesmovb (%rbi,%rcx),%al             Memory--Register,    1 bytemovb $-17,(%rsp)                 Immediate--Memory,   1 bytemovq %rax,-12(%rbp)              Register--Memory,    8 bytes\n\n\nmovabsq是处理64位立即数数据的。常规的movq指令只能以表示32位补码数字的立即数作为源操作数，然后将其符号拓展为64位放到目的位置。而movabsq能以64位立即数为源操作数，并且只能以寄存器作为目的。\n下图的数据移动指令在将较小的源值复制到较大的目的时使用。每条指令的最后两个字符都是大小指示符：第一个字符指定源的大小，第二个指明目的的大小。\n\n\n3.3.3 数据传送示例对于下面的C代码\nlong exchange(long *xp, long y){   long x = *xp;   *xp = y;   return x;}\n\n\n对应的汇编代码如下，其中寄存器%rdi和%rsi分别存放参数xp和y\nlong exchange(long *xp, long y)xp in %!r(MISSING)di, y in %!r(MISSING)siexchage:   movq     (%rdi), %rax            Get x at xp. Set as return value.   movq     %rsi, (%rdi)            Store y at xp.   ret                              Return.\n\n\n关于这段汇编代码有两点值得注意：\n\nC语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。\n像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。\n\n3.4.4 压入和弹出栈数据栈是一种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则。通过push操作把数据压入栈中，通过pop操作删除数据；它具有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。\n\n\n栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为栈顶。\npushq指令的功能是把数据压入到栈上，而popq指令是弹出数据。这些指令都只有一个操作数一一压入的数据源和弹出的数据目的。\n将一个四字值压人栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，指令pushq %rbp的行为等价于下面两条指令：\nsubq $8, %rsp               Decrement stack pointermovq %rbp, (%rsp)           Store %!r(MISSING)bp on stack\n\n\n弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8。因此，指令popq %rax等价于下面两条指令：\n\n\n图中前两栏给出的是，当%rsp为0x108，%rax为0x123时，执行指令pushq %rax的效果。首先%rsp会减8，得到0x100，然后会将0x123存放到内存地址0x100处。第三栏说明的是在执行完pushq后立即执行指令popq %rdx的效果。先从内存中读出值0x123，再写到寄存器%rdx中，然后，寄存器%rsp的值将增加回到0x108。如图中所示，值0x123仍然会保持在内存位置0xl00中，直到被覆盖（例如被另一条入栈操作覆盖）。无论如何，%rsp指向的地址总是栈顶。\n3.4 算术和逻辑操作\n下图中的指令类（除leaq外）有各种带不同大小操作数的变种。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。\n\n\n3.4.1 加载有效地址加载有效地址指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。这条指令可以为后面的内存引用产生指针，也可以简洁地描述普通的算术操作，例如：\nlong scale(long x, long y, long z){  long t = x + 4 * y + 12 * z;  return t;} \n\n\n编译时，该函数的算术运算以三条leap指令实现：\n  long scale(long x, long y, long z)  x in %!r(MISSING)di, y in %!r(MISSING)si, z in %!r(MISSING)dxscale:  leaq    (%rdi,%rsi,4), %rax       x + 4*y  leaq    (%rdx,%rdx,2), %rdx       z + 2*z = 3*z  leaq    (%rax,%rdx,4), %rax       (x+4*y) + 4*(3*z) = x + 4*y + 12*z  ret\n\n\nleaq指令能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。\n3.4.2 一元和二元操作对于一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。例如incq(%rsp)会使栈顶的8字节元素加1。\n而二元操作中，第二个操作数既是源又是目的。这种语法类似于C语言中的x-=y，不过源操作数是第一个，目的操作数是第二个。第一个操作数可以是立即数、寄存器或内存位置，第二个操作数可以是寄存器或内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存中读出值，执行操作，再把结果写回内存。\n例：假设下面的值存放在指定的内存地址和寄存器中：\n\n\n给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值：\n\n\n\n地址\n目的\n值\n\n\n\naddq %rcx, (%rax)\n0x100\n0x100\n\n\nsubq %rdx, 8(%rax)\n0x108\n0xA8\n\n\nimulq $16, (%rax,%rdx,8)\n0x118\n0x110\n\n\nincq 16(%rax)\n0x110\n0x14\n\n\ndecq %rcx\n%rcx\n0x0\n\n\nsubq %rdx, %rax\n%rax\n0xFD\n\n\n3.4.3 移位操作移位操作首先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器%cl中（只允许这个特定的寄存器作为操作数）。\n例如，下面的C语言代码：\nlong shift_left4_rightn(long x, long n){  x &lt;&lt;= 4;  x &gt;&gt;= n;  return x;}  \n\n\n其对应的汇编代码为：\n  long shift_left4_rightn(long x, long n)  x in %!r(MISSING)di, n in %!r(MISSING)sishift_left4_rightn:  movq      %rdi, %rax      Get x  salq      $4, %rax        x &lt;&lt;= 4  movl      %esi, %ecx      Get x (4 bytes)  sarq      %cl, %rax       x &gt;&gt;= n \n\n\n3.4.4 算术操作示例C语言代码：\nlong arith(long x, long y, long z){  long t1 = x ^ y;  long t2 = z * 48;  long t3 = t1 &amp; 0x0F0F0F0F;  long t4 = t2 - t3;  return t4;\n\n\n汇编代码：\nlong arith(long x, long y, long z)x in %!r(MISSING)di, y in %!r(MISSING)si, z in %!r(MISSING)dxarith:  xorq     %rsi, %rdi                 t1 = x ^ y  leaq     (%rdx, %rdx, 2), %rax      3 * z  salq     $4, %rax                   t2 = 16 * (3*z) = 48*z  andl     $252645135, %edi           t3 = t1 &amp; 0x0F0F0F0F  subq     %rdi, %rax                 Return t2 - t3  ret  \n\n\n3.4.5 特殊的算术操作两个64位有符号或无符号整数相乘得到的乘积需要128位来表示，x86-64指令集对128位（16字节，8字）数的操作提供有限的支持。\n\n\nimulq可以用于两个不同的乘法的操作，其中一种是从两个64位操作数产生64位乘积的双操作数指令；另一种是计算两个64位的全128位补码乘积的单操作数指令。\n例如，在小端机器上运行下面的C代码：\n#include &lt;inttypes.h&gt;typedef unsigned __int128 uint128_t;void store_uprod(uint128_t *dest, uint64_t x, uint64_t y){  *dest = x * (uint128_t) y;}\n\n\nGCC生成的汇编代码为：\nvoid store_uprod(uint128_t *dest, uint64_t x, uint64_t y)dest in %!r(MISSING)di, x in %!r(MISSING)si, y in %!r(MISSING)dxstore_uprod:    movq        %rsi, %rax            Copy x to multiplicand    mulq        %rdx                  Multiply by y    movq        %rax, (%rdi)          Store lower 8 bytes at dest    movq        %rdx, 8(%rdi)         Store upper 8 bytes at dest+8    ret \n\n\n对于除法和取模操作，由单操作数除法指令提供。有符号除法指令idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。\n对于更普遍的64位的被除数除法而言，被除数被存放在%rax中，%rdx的位应全设置为0（无符号运算）或者%rax的符号位（有符号运算）。后面这个操作可以用指令cqto完成，这个指令不需要操作数，它隐含读出%rax的符号位，并将它复制到%rdx的所有位。\n例如下面计算两个64位有符号数的商和余数的C语言代码：\nvoid remdiv(long x, long y, long *qp, long *rp){  long q = x/y;  long r = x%y;  *qp = q;  *rp = r;} \n\n\n汇编代码为：\nvoid remdiv(long x, long y, long *qp, long *rp)x in %!r(MISSING)di, y in %!r(MISSING)si, qp in %!r(MISSING)dx, rp in %!r(MISSING)cxremdiv:  movq       %rdx, %r8           Copy qp  movq       %rdi, %rax          Move x to lower 8 bytes of dividend  cqto                           Sign-extend to upper 8 bytes of dividend  idivq      %rsi                Divide by y  movq       %rax, (%r8)         Store quotient at qp  movq       %rdx, (%rcx)        Store remainder at rp  ret        \n\n\n在上述代码中，必须首先把参数qp保存到另一个寄存器中（第4行），因为除法操作要使用参数寄存器%rdx。接下来，第5~6行准备被除数，复制并符号扩展x。除法之后，寄存器%rax中的商被保存在qp（第8行），而寄存器%rdx中的余数被保存在rp（第9行）。\n3.5 控制\n机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。\n与数据相关的控制流是实现有条件行为的更一般和更常见的方法。\n用jump指令可以改变一组机器代码指令的执行顺序，jump指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种低级机制基础之上的指令序列，来实现C语言的控制结构。\n3.5.1 条件码除了整数寄存器，CPU还维护一组单个位的条件码寄存器，最常用的条件码有：\n\nCF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。\nZF：零标志。最近的操作得出的结果为0。\nSF：符号标志。最近的操作得到的结果为负数。\nOF：溢出标志。最近的操作导致一个补码溢出（正溢出或负溢出)。\n\n除了leaq之外，图3-10（3.4节首图）中列出的所有指令都会设置条件码。对于逻辑操作，进位标志和溢出标志会设置成0。对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为0。INC和DEC指令会设置溢出和零标志，但不会改变进位标志。\n除了上述指令，还有如下图所示的两类指令，它们只设置条件码而不改变任何其他寄存器\n\n\nCMP和SUB指令、TEST和AND指令行为一样，除了只设置条件码而不更新寄存器。对于CMP指令，如果两个数一样，会将零标志设置为1；对于TEST指令的典型用法是检查数字的正负（testq %rax, %rax），或其中一个操作数是一个掩码，用来指示哪些位应该被测试。\n3.5.2 访问条件码常用的条件码使用功能有3种：\n\n可以根据条件码的某种组合，将一个字节设置为0或者1\n可以条件跳转到程序的某个其他的部分\n可以有条件地传送数据\n\n对于第一种情况，由下图中的SET指令实现\n\n\n一个计算C语言表达式a &lt; b的典型指令序列为：（这里a和b都是long类型）\nint comp(data_t a, data_t b)a in %!r(MISSING)di, b in %!r(MISSING)sicomp:  cmpq     %rsi, %rdi       Compare a:b  注意比较顺序  setl     %al              Set low-order byte of %!e(MISSING)ax to 0 or 1  movzbl   %al, %eax        Clear reset of %!e(MISSING)ax (and rest of %!r(MISSING)ax)  movzbl指令不光会把%!e(MISSING)ax的高3个字节清零，还会把整个寄存器%!r(MISSING)ax的高4个字节都清零。  ret\n\n\n3.5.3 跳转指令\n\njmp指令是无条件跳转。可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。\n汇编语言中，直接跳转是给出一个编号作为跳转目标，例如jmp .L1，间接跳转是“*”后面跟一个操作数指示符，例如jmp *%rax用寄存器%rax中的值作为跳转目标，jmp *(%rax)以%rax中的值作为读地址，从内存中读出跳转目标。\n其他跳转指令都是有条件的——它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。\n3.5.4 跳转指令的编码跳转指令最常用的编码是PC相对的，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之差作为编码。\n下面是一个PC相对寻址的例子：\n  movq          %rdi, %rax  jmp           .L2.L3:  sarq          %rax.L2:  testq         %rax, %rax  jg            .L3  rep; ret\n\n\n汇编器产生的反汇编版本为：\n0:     48 89 f8         mov      %rdi, %rax3:     eb 03            jmp      8 &lt;loop+0x8&gt;5:     48 d1 f8         sar      %rax8:     48 85 c0         test     %rax, %raxb:     7f f8            jg       5 &lt;loop+0x5&gt;d:     f3 c3            repz retq\n\n\n右边反汇编器产生的注释中，第2行中跳转指令的跳转目标指明为0x8，第5行中跳转指令的跳转目标是0x5（反汇编器以十六进制格式给出所有的数字）。不过，观察指令的字节编码，会看到第一条跳转指令的目标编码（在第二个字节中）为0x03。把它加上0x5，也就是下一条指令的地址，就得到跳转目标地址0x8，也就是第4行指令的地址。\n类似地，第二个跳转指令的目标用单字节、补码表示编码为0xf8（-8）。将这个数加上0xd（13）即第6行指令的地址，得到0x5, 即第3行指令的地址。\n当执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。\n例1 下面je指令的目标是什么\n4003fa: 74 02           je     XXXXXX     //0x4003fc + 0x02 = 0x4003fe4003fc: ff d0           callq  *%rax\n\n\n例2 下面je指令的目标是什么\n40042f: 74 f4           je XXXXXX        //0x400431 + 0xf4 (-12) = 0x400425400431: 5d              \n\n\n例3 ja和pop指令的地址是多少\nX1: 77 02           ja   400547         //X1 + 2 = X2,             X1=400543X2: 5d              pop  %rbp           //X2 + 0x02 = 0x400547,    X2=400545\n\n\n3.5.5 用条件控制来实现条件分支","categories":["CSAPP笔记"]},{"title":"第二章 信息的表示和处理","url":"/2022/06/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","content":"第二章 信息的表示和处理2.1 信息存储\n大多数计算机使用8 位的块，或者字节 （byte）, 作为最小的可寻址的内存单位。\n机器级程序将内存视为一个非常大的字节数组，称为虚拟内存 （virtual memory） 。\n内存的每个字节都由一个唯一的数字来标识，称为它的地址 （address）。\n所有可能地址的集合就称为虚拟地址空间 （virtual address space），这个虚拟地址空间只是一个展现给机器级程序的概念性映像。\n2.1.1 十六进制表示法十六进制表示、十六进制和十进制的互相转换。\n2.1.2 字数据大小每台计算机都有一个字长 （word size）， 指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为位的机器而言，虚拟地址的范围为，程序最多访问个字节。\n32 位字长限制虚拟地址空间为4 千兆字节（写作4GB，1G=）, 也就是说，刚刚超过字节。扩展到64 位字长使得虚拟地址空间为16EB, 大约是字节。\n\n可移植性： 许多程序员假设一个声明为int 类型的程序对象能被用来存储一个指针。这在大多数32 位的机器上能正常工作，但是在一台64 位的机器上却会导致问题。\n2.1.3 寻址和字节顺序对于跨越多字节的程序对象，必须建立两个规则：这个对象的地址是什么 ，以及在内存中如何排列这些字节 。\n在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。\n某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，称为小端法 （little endian）；而另一些机器则按照从最高有效字节到最低有效字节的顺序存储，称为大端法 （big endian）。\n以int类型的变量x为例，假设其位于地址0x100处，它的16进制值为0x01234567。地址范围0x100~0x103的字节顺序依赖于机器的类型：\n\n\n在有些时候，字节顺序会成为问题：\n\n是在不同类型的机器之间通过网络传送二进制数据时， 一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关千字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。\n\n当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在阅读由反汇编器生成的机器级代码时。\n\n当编写规避正常的类型系统的程序时。\n\n\n打印程序对象的字节表示： \n#include &lt;stdio.h&gt;typedef unsigned char *byte_pointer;//用typedef将数据类型byte_pointer定义为一个指向类型为unsigned char的对象的指针void show_bytes(byte_pointer start,size_t len){//输入参数是一个字节序列的地址，用一个字节指针和一个字节数来表示。  size_t i;  for(i = 0;i &lt; len;i++){    printf(\"%.2x\",start[i]);//表示整数必须用至少两个数字的十六进制格式输出。  }  printf(\"\\n\");}//打印出每个以十六进制表示的字节。void show_int(int x){//&amp;x被强制类型转换为\"unsigned char *\"，即把这个指针看成指向一个字节序列的对象  show_bytes((byte_pointer) &amp;x,sizeof(int));//使用sizeof增加可移植性}void show_float(float x){  show_bytes((byte_pointer) &amp;x,sizeof(float));}void show_pointer(void *x){  show_bytes((byte_pointer) &amp;x,sizeof(void *));}void test_show_bytes(int val){  int ival = val;  float fval = (float) ival;  int *pval = &amp;ival;  show_int(ival);  show_float(fval);  show_pointer(pval);} \n\n\n2.1.4 表示字符串C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。\n在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。\n\n2.1.5 表示代码对于下面的C函数\nint sum(int x,int y){  return x+y;}\n\n\n在不同机器上生成的字节表示的机器代码是不同的：\nLinux 32    55 89 e5 8b 45 0c 03 45 08 c9 c3Windows     55 89 e5 8b 45 0c 03 45 08 5d c3Sum         81 c3 e0 08 90 02 00 09Linux 64    55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3\n\n\n不同的机器类型使用不同的且不兼容的指令和编码方式，二进制代码是不兼容的。\n计算机系统的一个基本概念是，从机器的角度来看，程序仅仅只是字节序列。\n2.1.6 布尔代数简介\n2.1.7 C语言中的位运算C语言使用的符号和布尔运算中使用的符号相同：|就是或，&amp;就是与，~就是取反，^就是异或\n位级运算的一个常见用法就是实现掩码 运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。例如：掩码0xFF（最低的8 位为1）表示一个字的低位字节。位级运算x&amp;0xFF生成一个由x的最低有效字节组成的值，而其他的字节就被置为0 。比如，对于x=0x89ABCDEF其表达式将得到0x000000EF\n2.1.8 C语言中的逻辑运算C语言中的逻辑运算符||、&amp;&amp;和!分别对应于命题逻辑中的OR、AND和NOT运算。\n逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或0，分别表示结果为TRUE或者FALSE。例如：\n\n\n2.1.9 C语言中的移位运算对于一个位表示为的操作数\n左移运算： x&lt;&lt;k生成位表示为的值。即向左移动位，丢弃最高的位，并在右端补个0。\n右移运算： x&gt;&gt;k，分为逻辑右移 和算术右移 。逻辑右移在左端补个0，得到结果是；算术右移在左端补个最高有效位的值，得到的结果是。\n\n\nC 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移，但是，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。\nJava对于如何进行右移有明确的定义，x&gt;&gt;k会将x进行算术右移，而x&gt;&gt;&gt;k会对x进行逻辑右移。\n对于一个由位组成的数据类型，当移动位时，实际位移量是通过计算得到的。例如，假设数据类型int为\nint      lval = 0xFEDCBA98  &lt;&lt; 32; //0xFEDCBA98int      aval = 0xFEDCBA98  &lt;&lt; 36; //0xFFEDCBA9unsigned uval = 0xFEDCBA98u &gt;&gt; 40; //0x00FEDCBA\n\n\n2.2 整数表示\n\n2.2.1 整数数据类型\n\n\nC数据类型\n32位\n64位\n\n\n\n[signed]char\n\n\n\n\nunsigned char\n\n\n\n\nshort\n\n\n\n\nunsigned short\n\n\n\n\nint\n\n\n\n\nunsigned long\n\n\n\n\nlong\n\n\n\n\nunsigned long\n\n\n\n\nint32_t\n\n\n\n\nuint_t\n\n\n\n\nint64_t\n\n\n\n\nuint64_t\n\n\n\n\nC和C++都支持有符号数（默认）和无符号数，Java只支持有符号数。\n2.2.2 无符号数的编码无符号数编码的定义： 对于向量：\n\n位所能表示的值的范围为：最小是0，最大是\n2.2.3 补码编码补码编码的定义： 对于向量：\n\n位所能表示的值的范围为：最小是，最大是\n\n2.2.4 有符号数和无符号数之间的转换补码转换为无符号数： 对满足的有：\n\n无符号数转换为补码： 对满足的有：\n\n的表示可以通过把 的反码加1得到，即“ 取反加1 ”。 （无论是负数转换为无符号数，还是无符号转换为负数都适用）\n2.2.5 C语言中的有符号数与无符号数显式强制类型转换：\nint tx,ty;unsigned ux,uy;tx = (int) ux;uy = (unsigned) ty;\n\n\n隐式类型转换：\nint tx,ty;unsigned ux,uy;tx = ux; //转换为有符号数uy = ty; //转换为无符号数\n\n\n在32位机器上运行以下代码： \nint x = -1;//1111 1111 1111 1111 1111 1111 1111 1111,0xFFFF FFFFunsigned u = 2147483648; //2^31,1000 0000 0000 0000 0000 0000 0000 0000,0x8000 0000printf(\"x = %u = %d\\n\",x,x); //x = 429497295 = -1printf(\"u = %u = %d\\n\",u,u); //u = 2147483648 = -2147483648\n\n\n2.2.6 拓展一个数字的位表示无符号数的零拓展： 定义宽度为的位向量和宽度为的位向量，其中。则。\n补码数的符号拓展： 定义宽度为的位向量和宽度为的位向量，其中。则。\n2.2.7 截断数字int x = 53191; //0000 0000 0000 0000 1100 1111 1100 0111short sx = (short) x; //-12345int y = sx; //-12345    12345-&gt;0011 0000 0011 1001\n\n\n截断无符号数： 令等于位向量，而是将其截断为位的结果：。令,。则。\n截断补码数值： 令等于位向量，而是将其截断为位的结果：。令,。则。\n2.2.8 关于有符号数与无符号数的建议**/* WARNING: This is buggy code. */** float sum_elements(float a[],unsigned length){  int i;  float result = 0;    for(i = 0;i &lt;= lenght-1;i++){    result += a[i];  }  return result;}\n\n\n当参数length等于0时，运行上面的代码应该返回0.0，可实际上运行时会遇到一个内存错误。\n因为参数length是无符号的，计算0-1将使用无符号运算，这等价于模数加法。结果得到。同样使用无符号数比较，而因为任何数都小于等于，所以总是为真，因此代码将试图访问数组a的非法元素。\n2.3 整数运算\n2.3.1 无符号加法无符号数加法（ ）： 对满足的和有：正常溢出\n检测无符号数加法中的溢出： 对在范围中的和，令。则对计算，当且仅当（或等价地）时，发生了溢出。\n无符号数求反：对满足的任意，其位的无符号逆元由下式给出：\n\n2.3.2 补码加法补码加法： 对满足的整数和，有：\n正溢出正常负溢出\n\n\n检测补码加法中的溢出： 对满足的和，令。当且仅当，但时，计算发生了正溢出。当且仅当，但时，计算发生了负溢出。\n2.3.3 补码的非补码的非： 对满足的，其补码的非由下式给出\n\n补码非的位级表示： （1）对每一位求补，再对结果加1（取反加1）\n\n\n（2）设是最右边的1的位置（从右往左数的第一个1），因而的位级表示形如，这个值的非写成二进制格式就是。也就是对位左边的所有位取反。\n2.3.4 无符号乘法无符号数乘法： 对满足的和有：\n\n2.3.5 补码乘法补码乘法： 对满足的和有：\n\n无符号和补码乘法的位级等价性： 给定长度为的位向量和，用补码形式的位向量表示来定义整数和：。用无符号形式的位向量表示来定义非负整数和：。则\n\n2.3.6 乘以常数乘以2的幂： 设为位模式表示的无符号整数。那么，对于任何，都认为给出了的位的无符号表示，这里右边增加了个\n与2的幂相乘的无符号乘法： C变量x和k有无符号数值和，且，则C表达式x&lt;&lt;k产生数值。\n与2的幂相乘的补码乘法： C变量x和k有补码值和无符号数值，且，则C表达式x&lt;&lt;k产生数值。\n由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况。例如对于表达式x*14，编译器会将其重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)或(x&lt;&lt;4)-(x&lt;&lt;1)。\n2.3.7 除以2的幂除以2的幂的无符号除法： C变量x和k有无符号数值和，且，则C表达式x&gt;&gt;k产生数值。\n\n除以2的幂的补码除法，向下舍入： C变量x和k有补码值和无符号数值，且，则当执行算术移位时，C表达式x&gt;&gt;k产生数值。\n\n除以2的幂的补码除法，向上舍入： C变量x和k有补码值和无符号数值，且，则当执行算术移位时，C表达式(x+(1&lt;&lt;k)-1)&gt;&gt;k产生数值。\n\n对于使用算术右移的补码机器，C表达式(x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k将会计算数值。\n\n写一个函数div16，对于整数参数x返回x/16的值。函数中不能使用除法、模运算、乘法、任何条件语句、任何比较运算符或任何循环。假设数据类型int是32位长，使用补码表示，右移是算术右移。\n\n/* 利用表达式x&gt;&gt;31产生一个字，如果x是负数，这个字为全1，否则为全0。   通过掩码屏蔽掉适当的位就可以得到期望的偏置值 */int div16(int x){  /* Compute bias to be either 0(x &gt;=0) or 15(x &lt; 0) */  int bias = (x&gt;&gt;31) &amp; 0xF;  return (x+bias) &gt;&gt;4;}\n\n\n2.4 浮点数\n浮点数对形如的有理数进行编码。\n2.4.1 二进制小数考虑一个形如\n\n的表示法，其中每个二进制数字，或者称为位，的取值范围是0和1，如下图所示。这种表示方法表示的数定义如下：\n\n\n\n2.4.2 IEEE浮点表示IEEE浮点数标准用的形式来表示一个数：\n\n符号： 决定这数是负数（）还是正数（），而对于数值0的符号位解释作为特殊情况处理\n\n尾数： 是一个二进制小数，它的范围是，或者是\n\n阶码： 的作用是对浮点数加权，这个权重是2的次幂（可能是负数）\n\n\n将浮点数的位表示划分为三个字段，分别对这些值进行编码：\n\n一个单独的符号位直接编码符号\n\n位的阶码字段exp=编码阶码\n\n位小数字段frac=编码尾数，但是编码出来的值也依赖于阶码字段的值是否等于0\n\n\n在单精度浮点格式中，s、exp和frac字段分别为位、 位和 位 ，得到一个32位的表示。在双精度浮点格式中，s、exp和frac字段分别为位、 位和 位 ，得到一个64位的表示。\n\n\n给定位表示，根据exp的值，被编码的值可以分成三种不同的情况：\n\n\n情况1：规格化的值 \n当exp的位模式既不全为0，又不全为1时，都属于这类情况。在这种情况中，阶码字段被解释为以偏置形式表示的有符号整数。也就是说，阶码的值是，其中是无符号数，其位表示为，而是一个等于（单精度是127，双精度是1023） 的偏置量。由此产生指数的取值范围，对于单精度是 ，而对于双精度是 。\n小数字段frac被解释为描述小数值，其中，其二进制表示为，也就是二进制小数点在最高有效位的左边。尾数定义为。这种方式也叫隐含的以1开头 的表示，因为可以把看成一个二进制表达式为的数字。实际上是用23位来表示一个24位的数字。\n情况2：非规格化的值 \n当阶码域全为0时，所表示的数是非规格化的形式。在这种情况下， 阶码值是（单精度是 ，双精度是 ），而尾数的值是，也就是小数字段的值，没有隐含的开头的1。\n情况3：特殊值 \n这一类数值是当阶码域全为1时出现的。当小数域全为0时，得到的值表示无穷，当时是正无穷，当时是负无穷。当小数域为非0时，表示。\n2.4.3 数字示例\n\n2.4.4 舍入\n向偶数舍入也被称为向最接近的值舍入，是默认的方式，试图找到一个最接近的匹配值。它将数字向上或者向下舍入，使得结果的最低有效数字是偶数。\n其他三种方式产生实际值的确界。向零舍入方式把正数向下舍入，把负数向上舍入，得到值，使得。向下舍入方式把正数和负数都向下舍入，得到值，使得。向上舍入方式把正数和负数都向上舍入，得到值，满足。\n对于向偶数舍入来讲，它最大的作用是在统计时使用。向偶数舍入可以让我们在统计时，将舍入产生的误差平均，从而尽可能的抵消 。而其它三种方式在这方面都是有一定缺陷的，向上和向下舍入会造成值的偏大或偏小。而对于向零舍入来讲，如果全是正数的时候则会造成结果偏小，全是负数的时候则会造成结果偏大。\n向偶数舍入规则 ：例如有效数字超出规定数位的多余数字是1001，它大于超出规定最低位的一半（即0.5），故最低位进1。如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数）即可。对于多余数字是1000（正好是最低位一半）的特殊情况，若最低位为0则舍掉多余位，最低为1则进位1，使得最低位仍为0（偶数）。 \n\n\n\n舍入前\n舍入后（舍入到最接近的二分之一）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4.5 浮点运算\n浮点加法不具有结合性。 例如，(3.14+1e10)-1e10结果为0.0，而3.14+(1e10-1e10)结果为3.14。\n\n浮点加法满足单调性： 如果，那么对于任何及的值，除了，都有。无符号或补码加法不具有这个性质。\n\n浮点乘法是可交换的，不具有结合性，在加法上不具有分配性，满足单调性，且只要 ，就有 。\n\n\n2.4.6 C语言中的浮点数\n所有的C语言版本提供了两种不同的浮点数据类型：float和double。在支持IEEE浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。\n\n这类机器使用向偶数舍入的舍入方式。\n\n因为C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍入方式或者得到诸如、、或者之类的特殊值。\n\n可以通过引入库函数math.h定义程序常数INFINITY和NAN。\n\n从float或double转换成int时，值会向零舍入。进一步来说，值可能会溢出。C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式（字长为时的）为整数不确定值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此(int) 1e10会得到-2147483648，即从一个正值变为一个负值。\n\n\n2.5 小结\n计算机将信息编码为位（比特），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。\nC语言的设计可以包容多种不同字长和数字编码的实现。64位字长的机器逐渐普及，并正在取代统治市场长达30多年的32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。\n大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码。在位级上理解这些编码，并且理解算术运算的数学特性，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。\n在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个位的值，这种行为是由函数和来描述的。C语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。\n由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于, 从而转换成零时，也会下溢。\n和大多数其他程序语言一样， C语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式x*x 能够得出负数。但是，无符号数和补码的运算都满足整数运算的许多其他属性，包括结合律、交换律和分配律。这就允许编译器做很多的优化。例如，用(x&lt;&lt;3)-x取代表达式7*x时，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以2 的幂之间的关系。\n我们已经看到了几种使用位级运算和算术运算组合的聪明方法。例如，使用补码运算， ~x+1等价于-x。另外一个例子，假设我们想要一个形如的位模式，由个后面紧跟着个组成。这些位模式有助于掩码运算。这种模式能够通过C表达式(1&lt;&lt;k)-1生成，利用的是这样一个属性，即我们想要的位模式的数值为。例如，表达式(1&lt;&lt;8)-1将产生位模式0xFF。\n浮点表示通过将数字编码为的形式来近似地表示实数。最常见的浮点表示方式是由IEEE标准754定义的。它提供了几种不同的精度，最常见的是单精度（32位）和双精度（64位）。IEEE浮点也能够表示特殊值、和 。\n必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算术属性，比如结合性。\n","categories":["CSAPP笔记"]}]